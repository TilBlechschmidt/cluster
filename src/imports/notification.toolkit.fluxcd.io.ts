// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Alert is the Schema for the alerts API
 *
 * @schema Alert
 */
export class Alert extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Alert"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta1',
    kind: 'Alert',
  }

  /**
   * Renders a Kubernetes manifest for "Alert".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertProps = {}): any {
    return {
      ...Alert.GVK,
      ...toJson_AlertProps(props),
    };
  }

  /**
   * Defines a "Alert" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertProps = {}) {
    super(scope, id, {
      ...Alert.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Alert.GVK,
      ...toJson_AlertProps(resolved),
    };
  }
}

/**
 * Alert is the Schema for the alerts API
 *
 * @schema Alert
 */
export interface AlertProps {
  /**
   * @schema Alert#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertSpec defines an alerting rule for events involving a list of objects
   *
   * @schema Alert#spec
   */
  readonly spec?: AlertSpec;

}

/**
 * Converts an object of type 'AlertProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertProps(obj: AlertProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertSpec defines an alerting rule for events involving a list of objects
 *
 * @schema AlertSpec
 */
export interface AlertSpec {
  /**
   * Filter events based on severity, defaults to ('info'). If set to 'info' no events will be filtered.
   *
   * @schema AlertSpec#eventSeverity
   */
  readonly eventSeverity?: AlertSpecEventSeverity;

  /**
   * Filter events based on the involved objects.
   *
   * @schema AlertSpec#eventSources
   */
  readonly eventSources: AlertSpecEventSources[];

  /**
   * A list of Golang regular expressions to be used for excluding messages.
   *
   * @schema AlertSpec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * Send events using this provider.
   *
   * @schema AlertSpec#providerRef
   */
  readonly providerRef: AlertSpecProviderRef;

  /**
   * Short description of the impact and affected cluster.
   *
   * @schema AlertSpec#summary
   */
  readonly summary?: string;

  /**
   * This flag tells the controller to suspend subsequent events dispatching. Defaults to false.
   *
   * @default false.
   * @schema AlertSpec#suspend
   */
  readonly suspend?: boolean;

}

/**
 * Converts an object of type 'AlertSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertSpec(obj: AlertSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventSeverity': obj.eventSeverity,
    'eventSources': obj.eventSources?.map(y => toJson_AlertSpecEventSources(y)),
    'exclusionList': obj.exclusionList?.map(y => y),
    'providerRef': toJson_AlertSpecProviderRef(obj.providerRef),
    'summary': obj.summary,
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Filter events based on severity, defaults to ('info'). If set to 'info' no events will be filtered.
 *
 * @schema AlertSpecEventSeverity
 */
export enum AlertSpecEventSeverity {
  /** info */
  INFO = "info",
  /** error */
  ERROR = "error",
}

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
 *
 * @schema AlertSpecEventSources
 */
export interface AlertSpecEventSources {
  /**
   * API version of the referent
   *
   * @schema AlertSpecEventSources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema AlertSpecEventSources#kind
   */
  readonly kind?: AlertSpecEventSourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema AlertSpecEventSources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   *
   * @schema AlertSpecEventSources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema AlertSpecEventSources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AlertSpecEventSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertSpecEventSources(obj: AlertSpecEventSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Send events using this provider.
 *
 * @schema AlertSpecProviderRef
 */
export interface AlertSpecProviderRef {
  /**
   * Name of the referent.
   *
   * @schema AlertSpecProviderRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertSpecProviderRef(obj: AlertSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent
 *
 * @schema AlertSpecEventSourcesKind
 */
export enum AlertSpecEventSourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Alert is the Schema for the alerts API
 *
 * @schema AlertV1Beta2
 */
export class AlertV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Alert',
  }

  /**
   * Renders a Kubernetes manifest for "AlertV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertV1Beta2Props = {}): any {
    return {
      ...AlertV1Beta2.GVK,
      ...toJson_AlertV1Beta2Props(props),
    };
  }

  /**
   * Defines a "AlertV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertV1Beta2Props = {}) {
    super(scope, id, {
      ...AlertV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertV1Beta2.GVK,
      ...toJson_AlertV1Beta2Props(resolved),
    };
  }
}

/**
 * Alert is the Schema for the alerts API
 *
 * @schema AlertV1Beta2
 */
export interface AlertV1Beta2Props {
  /**
   * @schema AlertV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertSpec defines an alerting rule for events involving a list of objects.
   *
   * @schema AlertV1Beta2#spec
   */
  readonly spec?: AlertV1Beta2Spec;

}

/**
 * Converts an object of type 'AlertV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertV1Beta2Props(obj: AlertV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertSpec defines an alerting rule for events involving a list of objects.
 *
 * @schema AlertV1Beta2Spec
 */
export interface AlertV1Beta2Spec {
  /**
   * EventSeverity specifies how to filter events based on severity. If set to 'info' no events will be filtered.
   *
   * @schema AlertV1Beta2Spec#eventSeverity
   */
  readonly eventSeverity?: AlertV1Beta2SpecEventSeverity;

  /**
   * EventSources specifies how to filter events based on the involved object kind, name and namespace.
   *
   * @schema AlertV1Beta2Spec#eventSources
   */
  readonly eventSources: AlertV1Beta2SpecEventSources[];

  /**
   * ExclusionList specifies a list of Golang regular expressions to be used for excluding messages.
   *
   * @schema AlertV1Beta2Spec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * ProviderRef specifies which Provider this Alert should use.
   *
   * @schema AlertV1Beta2Spec#providerRef
   */
  readonly providerRef: AlertV1Beta2SpecProviderRef;

  /**
   * Summary holds a short description of the impact and affected cluster.
   *
   * @schema AlertV1Beta2Spec#summary
   */
  readonly summary?: string;

  /**
   * Suspend tells the controller to suspend subsequent events handling for this Alert.
   *
   * @schema AlertV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

}

/**
 * Converts an object of type 'AlertV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertV1Beta2Spec(obj: AlertV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventSeverity': obj.eventSeverity,
    'eventSources': obj.eventSources?.map(y => toJson_AlertV1Beta2SpecEventSources(y)),
    'exclusionList': obj.exclusionList?.map(y => y),
    'providerRef': toJson_AlertV1Beta2SpecProviderRef(obj.providerRef),
    'summary': obj.summary,
    'suspend': obj.suspend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSeverity specifies how to filter events based on severity. If set to 'info' no events will be filtered.
 *
 * @schema AlertV1Beta2SpecEventSeverity
 */
export enum AlertV1Beta2SpecEventSeverity {
  /** info */
  INFO = "info",
  /** error */
  ERROR = "error",
}

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
 *
 * @schema AlertV1Beta2SpecEventSources
 */
export interface AlertV1Beta2SpecEventSources {
  /**
   * API version of the referent
   *
   * @schema AlertV1Beta2SpecEventSources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema AlertV1Beta2SpecEventSources#kind
   */
  readonly kind: AlertV1Beta2SpecEventSourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. MatchLabels requires the name to be set to `*`.
   *
   * @schema AlertV1Beta2SpecEventSources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent If multiple resources are targeted `*` may be set.
   *
   * @schema AlertV1Beta2SpecEventSources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema AlertV1Beta2SpecEventSources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AlertV1Beta2SpecEventSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertV1Beta2SpecEventSources(obj: AlertV1Beta2SpecEventSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderRef specifies which Provider this Alert should use.
 *
 * @schema AlertV1Beta2SpecProviderRef
 */
export interface AlertV1Beta2SpecProviderRef {
  /**
   * Name of the referent.
   *
   * @schema AlertV1Beta2SpecProviderRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertV1Beta2SpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertV1Beta2SpecProviderRef(obj: AlertV1Beta2SpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent
 *
 * @schema AlertV1Beta2SpecEventSourcesKind
 */
export enum AlertV1Beta2SpecEventSourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Provider is the Schema for the providers API
 *
 * @schema Provider
 */
export class Provider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Provider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta1',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "Provider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderProps = {}): any {
    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(props),
    };
  }

  /**
   * Defines a "Provider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderProps = {}) {
    super(scope, id, {
      ...Provider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Provider.GVK,
      ...toJson_ProviderProps(resolved),
    };
  }
}

/**
 * Provider is the Schema for the providers API
 *
 * @schema Provider
 */
export interface ProviderProps {
  /**
   * @schema Provider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec defines the desired state of Provider
   *
   * @schema Provider#spec
   */
  readonly spec?: ProviderSpec;

}

/**
 * Converts an object of type 'ProviderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderProps(obj: ProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderSpec defines the desired state of Provider
 *
 * @schema ProviderSpec
 */
export interface ProviderSpec {
  /**
   * HTTP/S webhook address of this provider
   *
   * @schema ProviderSpec#address
   */
  readonly address?: string;

  /**
   * CertSecretRef can be given the name of a secret containing a PEM-encoded CA certificate (`caFile`)
   *
   * @schema ProviderSpec#certSecretRef
   */
  readonly certSecretRef?: ProviderSpecCertSecretRef;

  /**
   * Alert channel for this provider
   *
   * @schema ProviderSpec#channel
   */
  readonly channel?: string;

  /**
   * HTTP/S address of the proxy
   *
   * @schema ProviderSpec#proxy
   */
  readonly proxy?: string;

  /**
   * Secret reference containing the provider webhook URL using "address" as data key
   *
   * @schema ProviderSpec#secretRef
   */
  readonly secretRef?: ProviderSpecSecretRef;

  /**
   * This flag tells the controller to suspend subsequent events handling. Defaults to false.
   *
   * @default false.
   * @schema ProviderSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for sending alerts to the provider.
   *
   * @schema ProviderSpec#timeout
   */
  readonly timeout?: string;

  /**
   * Type of provider
   *
   * @schema ProviderSpec#type
   */
  readonly type: ProviderSpecType;

  /**
   * Bot username for this provider
   *
   * @schema ProviderSpec#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpec(obj: ProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'certSecretRef': toJson_ProviderSpecCertSecretRef(obj.certSecretRef),
    'channel': obj.channel,
    'proxy': obj.proxy,
    'secretRef': toJson_ProviderSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertSecretRef can be given the name of a secret containing a PEM-encoded CA certificate (`caFile`)
 *
 * @schema ProviderSpecCertSecretRef
 */
export interface ProviderSpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderSpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderSpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecCertSecretRef(obj: ProviderSpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret reference containing the provider webhook URL using "address" as data key
 *
 * @schema ProviderSpecSecretRef
 */
export interface ProviderSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderSpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderSpecSecretRef(obj: ProviderSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of provider
 *
 * @schema ProviderSpecType
 */
export enum ProviderSpecType {
  /** slack */
  SLACK = "slack",
  /** discord */
  DISCORD = "discord",
  /** msteams */
  MSTEAMS = "msteams",
  /** rocket */
  ROCKET = "rocket",
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** azuredevops */
  AZUREDEVOPS = "azuredevops",
  /** googlechat */
  GOOGLECHAT = "googlechat",
  /** webex */
  WEBEX = "webex",
  /** sentry */
  SENTRY = "sentry",
  /** azureeventhub */
  AZUREEVENTHUB = "azureeventhub",
  /** telegram */
  TELEGRAM = "telegram",
  /** lark */
  LARK = "lark",
  /** matrix */
  MATRIX = "matrix",
  /** opsgenie */
  OPSGENIE = "opsgenie",
  /** alertmanager */
  ALERTMANAGER = "alertmanager",
  /** grafana */
  GRAFANA = "grafana",
  /** githubdispatch */
  GITHUBDISPATCH = "githubdispatch",
}


/**
 * Provider is the Schema for the providers API.
 *
 * @schema ProviderV1Beta2
 */
export class ProviderV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProviderV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Provider',
  }

  /**
   * Renders a Kubernetes manifest for "ProviderV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProviderV1Beta2Props = {}): any {
    return {
      ...ProviderV1Beta2.GVK,
      ...toJson_ProviderV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ProviderV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProviderV1Beta2Props = {}) {
    super(scope, id, {
      ...ProviderV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProviderV1Beta2.GVK,
      ...toJson_ProviderV1Beta2Props(resolved),
    };
  }
}

/**
 * Provider is the Schema for the providers API.
 *
 * @schema ProviderV1Beta2
 */
export interface ProviderV1Beta2Props {
  /**
   * @schema ProviderV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProviderSpec defines the desired state of the Provider.
   *
   * @schema ProviderV1Beta2#spec
   */
  readonly spec?: ProviderV1Beta2Spec;

}

/**
 * Converts an object of type 'ProviderV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Beta2Props(obj: ProviderV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProviderV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderSpec defines the desired state of the Provider.
 *
 * @schema ProviderV1Beta2Spec
 */
export interface ProviderV1Beta2Spec {
  /**
   * Address specifies the HTTP/S incoming webhook address of this Provider.
   *
   * @schema ProviderV1Beta2Spec#address
   */
  readonly address?: string;

  /**
   * CertSecretRef specifies the Secret containing a PEM-encoded CA certificate (`caFile`).
   *
   * @schema ProviderV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: ProviderV1Beta2SpecCertSecretRef;

  /**
   * Channel specifies the destination channel where events should be posted.
   *
   * @schema ProviderV1Beta2Spec#channel
   */
  readonly channel?: string;

  /**
   * Interval at which to reconcile the Provider with its Secret references.
   *
   * @schema ProviderV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * Proxy the HTTP/S address of the proxy server.
   *
   * @schema ProviderV1Beta2Spec#proxy
   */
  readonly proxy?: string;

  /**
   * SecretRef specifies the Secret containing the authentication credentials for this Provider.
   *
   * @schema ProviderV1Beta2Spec#secretRef
   */
  readonly secretRef?: ProviderV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent events handling for this Provider.
   *
   * @schema ProviderV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for sending alerts to the Provider.
   *
   * @schema ProviderV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * Type specifies which Provider implementation to use.
   *
   * @schema ProviderV1Beta2Spec#type
   */
  readonly type: ProviderV1Beta2SpecType;

  /**
   * Username specifies the name under which events are posted.
   *
   * @schema ProviderV1Beta2Spec#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ProviderV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Beta2Spec(obj: ProviderV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'certSecretRef': toJson_ProviderV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'channel': obj.channel,
    'interval': obj.interval,
    'proxy': obj.proxy,
    'secretRef': toJson_ProviderV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertSecretRef specifies the Secret containing a PEM-encoded CA certificate (`caFile`).
 *
 * @schema ProviderV1Beta2SpecCertSecretRef
 */
export interface ProviderV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Beta2SpecCertSecretRef(obj: ProviderV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the Secret containing the authentication credentials for this Provider.
 *
 * @schema ProviderV1Beta2SpecSecretRef
 */
export interface ProviderV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ProviderV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProviderV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProviderV1Beta2SpecSecretRef(obj: ProviderV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type specifies which Provider implementation to use.
 *
 * @schema ProviderV1Beta2SpecType
 */
export enum ProviderV1Beta2SpecType {
  /** slack */
  SLACK = "slack",
  /** discord */
  DISCORD = "discord",
  /** msteams */
  MSTEAMS = "msteams",
  /** rocket */
  ROCKET = "rocket",
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** gitea */
  GITEA = "gitea",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** azuredevops */
  AZUREDEVOPS = "azuredevops",
  /** googlechat */
  GOOGLECHAT = "googlechat",
  /** webex */
  WEBEX = "webex",
  /** sentry */
  SENTRY = "sentry",
  /** azureeventhub */
  AZUREEVENTHUB = "azureeventhub",
  /** telegram */
  TELEGRAM = "telegram",
  /** lark */
  LARK = "lark",
  /** matrix */
  MATRIX = "matrix",
  /** opsgenie */
  OPSGENIE = "opsgenie",
  /** alertmanager */
  ALERTMANAGER = "alertmanager",
  /** grafana */
  GRAFANA = "grafana",
  /** githubdispatch */
  GITHUBDISPATCH = "githubdispatch",
}


/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema Receiver
 */
export class Receiver extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Receiver"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1',
    kind: 'Receiver',
  }

  /**
   * Renders a Kubernetes manifest for "Receiver".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiverProps = {}): any {
    return {
      ...Receiver.GVK,
      ...toJson_ReceiverProps(props),
    };
  }

  /**
   * Defines a "Receiver" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiverProps = {}) {
    super(scope, id, {
      ...Receiver.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Receiver.GVK,
      ...toJson_ReceiverProps(resolved),
    };
  }
}

/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema Receiver
 */
export interface ReceiverProps {
  /**
   * @schema Receiver#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiverSpec defines the desired state of the Receiver.
   *
   * @schema Receiver#spec
   */
  readonly spec?: ReceiverSpec;

}

/**
 * Converts an object of type 'ReceiverProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverProps(obj: ReceiverProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiverSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiverSpec defines the desired state of the Receiver.
 *
 * @schema ReceiverSpec
 */
export interface ReceiverSpec {
  /**
   * Events specifies the list of event types to handle, e.g. 'push' for GitHub or 'Push Hook' for GitLab.
   *
   * @schema ReceiverSpec#events
   */
  readonly events?: string[];

  /**
   * Interval at which to reconcile the Receiver with its Secret references.
   *
   * @schema ReceiverSpec#interval
   */
  readonly interval?: string;

  /**
   * A list of resources to be notified about changes.
   *
   * @schema ReceiverSpec#resources
   */
  readonly resources: ReceiverSpecResources[];

  /**
   * SecretRef specifies the Secret containing the token used to validate the payload authenticity.
   *
   * @schema ReceiverSpec#secretRef
   */
  readonly secretRef: ReceiverSpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent events handling for this receiver.
   *
   * @schema ReceiverSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Type of webhook sender, used to determine the validation procedure and payload deserialization.
   *
   * @schema ReceiverSpec#type
   */
  readonly type: ReceiverSpecType;

}

/**
 * Converts an object of type 'ReceiverSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverSpec(obj: ReceiverSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'interval': obj.interval,
    'resources': obj.resources?.map(y => toJson_ReceiverSpecResources(y)),
    'secretRef': toJson_ReceiverSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
 *
 * @schema ReceiverSpecResources
 */
export interface ReceiverSpecResources {
  /**
   * API version of the referent
   *
   * @schema ReceiverSpecResources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema ReceiverSpecResources#kind
   */
  readonly kind: ReceiverSpecResourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. MatchLabels requires the name to be set to `*`.
   *
   * @schema ReceiverSpecResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent If multiple resources are targeted `*` may be set.
   *
   * @schema ReceiverSpecResources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema ReceiverSpecResources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ReceiverSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverSpecResources(obj: ReceiverSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the Secret containing the token used to validate the payload authenticity.
 *
 * @schema ReceiverSpecSecretRef
 */
export interface ReceiverSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ReceiverSpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiverSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverSpecSecretRef(obj: ReceiverSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of webhook sender, used to determine the validation procedure and payload deserialization.
 *
 * @schema ReceiverSpecType
 */
export enum ReceiverSpecType {
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** harbor */
  HARBOR = "harbor",
  /** dockerhub */
  DOCKERHUB = "dockerhub",
  /** quay */
  QUAY = "quay",
  /** gcr */
  GCR = "gcr",
  /** nexus */
  NEXUS = "nexus",
  /** acr */
  ACR = "acr",
}

/**
 * Kind of the referent
 *
 * @schema ReceiverSpecResourcesKind
 */
export enum ReceiverSpecResourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Receiver is the Schema for the receivers API
 *
 * @schema ReceiverV1Beta1
 */
export class ReceiverV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiverV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta1',
    kind: 'Receiver',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiverV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiverV1Beta1Props = {}): any {
    return {
      ...ReceiverV1Beta1.GVK,
      ...toJson_ReceiverV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ReceiverV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiverV1Beta1Props = {}) {
    super(scope, id, {
      ...ReceiverV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiverV1Beta1.GVK,
      ...toJson_ReceiverV1Beta1Props(resolved),
    };
  }
}

/**
 * Receiver is the Schema for the receivers API
 *
 * @schema ReceiverV1Beta1
 */
export interface ReceiverV1Beta1Props {
  /**
   * @schema ReceiverV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiverSpec defines the desired state of Receiver
   *
   * @schema ReceiverV1Beta1#spec
   */
  readonly spec?: ReceiverV1Beta1Spec;

}

/**
 * Converts an object of type 'ReceiverV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta1Props(obj: ReceiverV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiverV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiverSpec defines the desired state of Receiver
 *
 * @schema ReceiverV1Beta1Spec
 */
export interface ReceiverV1Beta1Spec {
  /**
   * A list of events to handle, e.g. 'push' for GitHub or 'Push Hook' for GitLab.
   *
   * @schema ReceiverV1Beta1Spec#events
   */
  readonly events?: string[];

  /**
   * A list of resources to be notified about changes.
   *
   * @schema ReceiverV1Beta1Spec#resources
   */
  readonly resources: ReceiverV1Beta1SpecResources[];

  /**
   * Secret reference containing the token used to validate the payload authenticity
   *
   * @schema ReceiverV1Beta1Spec#secretRef
   */
  readonly secretRef?: ReceiverV1Beta1SpecSecretRef;

  /**
   * This flag tells the controller to suspend subsequent events handling. Defaults to false.
   *
   * @default false.
   * @schema ReceiverV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Type of webhook sender, used to determine the validation procedure and payload deserialization.
   *
   * @schema ReceiverV1Beta1Spec#type
   */
  readonly type: ReceiverV1Beta1SpecType;

}

/**
 * Converts an object of type 'ReceiverV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta1Spec(obj: ReceiverV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'resources': obj.resources?.map(y => toJson_ReceiverV1Beta1SpecResources(y)),
    'secretRef': toJson_ReceiverV1Beta1SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
 *
 * @schema ReceiverV1Beta1SpecResources
 */
export interface ReceiverV1Beta1SpecResources {
  /**
   * API version of the referent
   *
   * @schema ReceiverV1Beta1SpecResources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema ReceiverV1Beta1SpecResources#kind
   */
  readonly kind?: ReceiverV1Beta1SpecResourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ReceiverV1Beta1SpecResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent
   *
   * @schema ReceiverV1Beta1SpecResources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema ReceiverV1Beta1SpecResources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ReceiverV1Beta1SpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta1SpecResources(obj: ReceiverV1Beta1SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret reference containing the token used to validate the payload authenticity
 *
 * @schema ReceiverV1Beta1SpecSecretRef
 */
export interface ReceiverV1Beta1SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ReceiverV1Beta1SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiverV1Beta1SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta1SpecSecretRef(obj: ReceiverV1Beta1SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of webhook sender, used to determine the validation procedure and payload deserialization.
 *
 * @schema ReceiverV1Beta1SpecType
 */
export enum ReceiverV1Beta1SpecType {
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** harbor */
  HARBOR = "harbor",
  /** dockerhub */
  DOCKERHUB = "dockerhub",
  /** quay */
  QUAY = "quay",
  /** gcr */
  GCR = "gcr",
  /** nexus */
  NEXUS = "nexus",
  /** acr */
  ACR = "acr",
}

/**
 * Kind of the referent
 *
 * @schema ReceiverV1Beta1SpecResourcesKind
 */
export enum ReceiverV1Beta1SpecResourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}


/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema ReceiverV1Beta2
 */
export class ReceiverV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReceiverV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notification.toolkit.fluxcd.io/v1beta2',
    kind: 'Receiver',
  }

  /**
   * Renders a Kubernetes manifest for "ReceiverV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReceiverV1Beta2Props = {}): any {
    return {
      ...ReceiverV1Beta2.GVK,
      ...toJson_ReceiverV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ReceiverV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReceiverV1Beta2Props = {}) {
    super(scope, id, {
      ...ReceiverV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReceiverV1Beta2.GVK,
      ...toJson_ReceiverV1Beta2Props(resolved),
    };
  }
}

/**
 * Receiver is the Schema for the receivers API.
 *
 * @schema ReceiverV1Beta2
 */
export interface ReceiverV1Beta2Props {
  /**
   * @schema ReceiverV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReceiverSpec defines the desired state of the Receiver.
   *
   * @schema ReceiverV1Beta2#spec
   */
  readonly spec?: ReceiverV1Beta2Spec;

}

/**
 * Converts an object of type 'ReceiverV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta2Props(obj: ReceiverV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReceiverV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReceiverSpec defines the desired state of the Receiver.
 *
 * @schema ReceiverV1Beta2Spec
 */
export interface ReceiverV1Beta2Spec {
  /**
   * Events specifies the list of event types to handle, e.g. 'push' for GitHub or 'Push Hook' for GitLab.
   *
   * @schema ReceiverV1Beta2Spec#events
   */
  readonly events?: string[];

  /**
   * Interval at which to reconcile the Receiver with its Secret references.
   *
   * @schema ReceiverV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * A list of resources to be notified about changes.
   *
   * @schema ReceiverV1Beta2Spec#resources
   */
  readonly resources: ReceiverV1Beta2SpecResources[];

  /**
   * SecretRef specifies the Secret containing the token used to validate the payload authenticity.
   *
   * @schema ReceiverV1Beta2Spec#secretRef
   */
  readonly secretRef?: ReceiverV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend subsequent events handling for this receiver.
   *
   * @schema ReceiverV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Type of webhook sender, used to determine the validation procedure and payload deserialization.
   *
   * @schema ReceiverV1Beta2Spec#type
   */
  readonly type: ReceiverV1Beta2SpecType;

}

/**
 * Converts an object of type 'ReceiverV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta2Spec(obj: ReceiverV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'events': obj.events?.map(y => y),
    'interval': obj.interval,
    'resources': obj.resources?.map(y => toJson_ReceiverV1Beta2SpecResources(y)),
    'secretRef': toJson_ReceiverV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
 *
 * @schema ReceiverV1Beta2SpecResources
 */
export interface ReceiverV1Beta2SpecResources {
  /**
   * API version of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#kind
   */
  readonly kind: ReceiverV1Beta2SpecResourcesKind;

  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed. MatchLabels requires the name to be set to `*`.
   *
   * @schema ReceiverV1Beta2SpecResources#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name of the referent If multiple resources are targeted `*` may be set.
   *
   * @schema ReceiverV1Beta2SpecResources#name
   */
  readonly name: string;

  /**
   * Namespace of the referent
   *
   * @schema ReceiverV1Beta2SpecResources#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ReceiverV1Beta2SpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta2SpecResources(obj: ReceiverV1Beta2SpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the Secret containing the token used to validate the payload authenticity.
 *
 * @schema ReceiverV1Beta2SpecSecretRef
 */
export interface ReceiverV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ReceiverV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReceiverV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReceiverV1Beta2SpecSecretRef(obj: ReceiverV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of webhook sender, used to determine the validation procedure and payload deserialization.
 *
 * @schema ReceiverV1Beta2SpecType
 */
export enum ReceiverV1Beta2SpecType {
  /** generic */
  GENERIC = "generic",
  /** generic-hmac */
  GENERIC_HMAC = "generic-hmac",
  /** github */
  GITHUB = "github",
  /** gitlab */
  GITLAB = "gitlab",
  /** bitbucket */
  BITBUCKET = "bitbucket",
  /** harbor */
  HARBOR = "harbor",
  /** dockerhub */
  DOCKERHUB = "dockerhub",
  /** quay */
  QUAY = "quay",
  /** gcr */
  GCR = "gcr",
  /** nexus */
  NEXUS = "nexus",
  /** acr */
  ACR = "acr",
}

/**
 * Kind of the referent
 *
 * @schema ReceiverV1Beta2SpecResourcesKind
 */
export enum ReceiverV1Beta2SpecResourcesKind {
  /** Bucket */
  BUCKET = "Bucket",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Kustomization */
  KUSTOMIZATION = "Kustomization",
  /** HelmRelease */
  HELM_RELEASE = "HelmRelease",
  /** HelmChart */
  HELM_CHART = "HelmChart",
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** ImageRepository */
  IMAGE_REPOSITORY = "ImageRepository",
  /** ImagePolicy */
  IMAGE_POLICY = "ImagePolicy",
  /** ImageUpdateAutomation */
  IMAGE_UPDATE_AUTOMATION = "ImageUpdateAutomation",
  /** OCIRepository */
  OCI_REPOSITORY = "OCIRepository",
}

