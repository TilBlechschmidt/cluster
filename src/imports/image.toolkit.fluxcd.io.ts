// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicy
 */
export class ImagePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImagePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta1',
    kind: 'ImagePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ImagePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImagePolicyProps = {}): any {
    return {
      ...ImagePolicy.GVK,
      ...toJson_ImagePolicyProps(props),
    };
  }

  /**
   * Defines a "ImagePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImagePolicyProps = {}) {
    super(scope, id, {
      ...ImagePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImagePolicy.GVK,
      ...toJson_ImagePolicyProps(resolved),
    };
  }
}

/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicy
 */
export interface ImagePolicyProps {
  /**
   * @schema ImagePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImagePolicySpec defines the parameters for calculating the ImagePolicy
   *
   * @schema ImagePolicy#spec
   */
  readonly spec?: ImagePolicySpec;

}

/**
 * Converts an object of type 'ImagePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyProps(obj: ImagePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImagePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImagePolicySpec defines the parameters for calculating the ImagePolicy
 *
 * @schema ImagePolicySpec
 */
export interface ImagePolicySpec {
  /**
   * FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
   *
   * @schema ImagePolicySpec#filterTags
   */
  readonly filterTags?: ImagePolicySpecFilterTags;

  /**
   * ImageRepositoryRef points at the object specifying the image being scanned
   *
   * @schema ImagePolicySpec#imageRepositoryRef
   */
  readonly imageRepositoryRef: ImagePolicySpecImageRepositoryRef;

  /**
   * Policy gives the particulars of the policy to be followed in selecting the most recent image
   *
   * @schema ImagePolicySpec#policy
   */
  readonly policy: ImagePolicySpecPolicy;

}

/**
 * Converts an object of type 'ImagePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpec(obj: ImagePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterTags': toJson_ImagePolicySpecFilterTags(obj.filterTags),
    'imageRepositoryRef': toJson_ImagePolicySpecImageRepositoryRef(obj.imageRepositoryRef),
    'policy': toJson_ImagePolicySpecPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
 *
 * @schema ImagePolicySpecFilterTags
 */
export interface ImagePolicySpecFilterTags {
  /**
   * Extract allows a capture group to be extracted from the specified regular expression pattern, useful before tag evaluation.
   *
   * @schema ImagePolicySpecFilterTags#extract
   */
  readonly extract?: string;

  /**
   * Pattern specifies a regular expression pattern used to filter for image tags.
   *
   * @schema ImagePolicySpecFilterTags#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'ImagePolicySpecFilterTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecFilterTags(obj: ImagePolicySpecFilterTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': obj.extract,
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRepositoryRef points at the object specifying the image being scanned
 *
 * @schema ImagePolicySpecImageRepositoryRef
 */
export interface ImagePolicySpecImageRepositoryRef {
  /**
   * Name of the referent.
   *
   * @schema ImagePolicySpecImageRepositoryRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, when not specified it acts as LocalObjectReference.
   *
   * @schema ImagePolicySpecImageRepositoryRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ImagePolicySpecImageRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecImageRepositoryRef(obj: ImagePolicySpecImageRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy gives the particulars of the policy to be followed in selecting the most recent image
 *
 * @schema ImagePolicySpecPolicy
 */
export interface ImagePolicySpecPolicy {
  /**
   * Alphabetical set of rules to use for alphabetical ordering of the tags.
   *
   * @schema ImagePolicySpecPolicy#alphabetical
   */
  readonly alphabetical?: ImagePolicySpecPolicyAlphabetical;

  /**
   * Numerical set of rules to use for numerical ordering of the tags.
   *
   * @schema ImagePolicySpecPolicy#numerical
   */
  readonly numerical?: ImagePolicySpecPolicyNumerical;

  /**
   * SemVer gives a semantic version range to check against the tags available.
   *
   * @schema ImagePolicySpecPolicy#semver
   */
  readonly semver?: ImagePolicySpecPolicySemver;

}

/**
 * Converts an object of type 'ImagePolicySpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecPolicy(obj: ImagePolicySpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alphabetical': toJson_ImagePolicySpecPolicyAlphabetical(obj.alphabetical),
    'numerical': toJson_ImagePolicySpecPolicyNumerical(obj.numerical),
    'semver': toJson_ImagePolicySpecPolicySemver(obj.semver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Alphabetical set of rules to use for alphabetical ordering of the tags.
 *
 * @schema ImagePolicySpecPolicyAlphabetical
 */
export interface ImagePolicySpecPolicyAlphabetical {
  /**
   * Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
   *
   * @schema ImagePolicySpecPolicyAlphabetical#order
   */
  readonly order?: ImagePolicySpecPolicyAlphabeticalOrder;

}

/**
 * Converts an object of type 'ImagePolicySpecPolicyAlphabetical' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecPolicyAlphabetical(obj: ImagePolicySpecPolicyAlphabetical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Numerical set of rules to use for numerical ordering of the tags.
 *
 * @schema ImagePolicySpecPolicyNumerical
 */
export interface ImagePolicySpecPolicyNumerical {
  /**
   * Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
   *
   * @schema ImagePolicySpecPolicyNumerical#order
   */
  readonly order?: ImagePolicySpecPolicyNumericalOrder;

}

/**
 * Converts an object of type 'ImagePolicySpecPolicyNumerical' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecPolicyNumerical(obj: ImagePolicySpecPolicyNumerical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SemVer gives a semantic version range to check against the tags available.
 *
 * @schema ImagePolicySpecPolicySemver
 */
export interface ImagePolicySpecPolicySemver {
  /**
   * Range gives a semver range for the image tag; the highest version within the range that's a tag yields the latest image.
   *
   * @schema ImagePolicySpecPolicySemver#range
   */
  readonly range: string;

}

/**
 * Converts an object of type 'ImagePolicySpecPolicySemver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicySpecPolicySemver(obj: ImagePolicySpecPolicySemver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
 *
 * @schema ImagePolicySpecPolicyAlphabeticalOrder
 */
export enum ImagePolicySpecPolicyAlphabeticalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}

/**
 * Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
 *
 * @schema ImagePolicySpecPolicyNumericalOrder
 */
export enum ImagePolicySpecPolicyNumericalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}


/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicyV1Beta2
 */
export class ImagePolicyV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImagePolicyV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta2',
    kind: 'ImagePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ImagePolicyV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImagePolicyV1Beta2Props = {}): any {
    return {
      ...ImagePolicyV1Beta2.GVK,
      ...toJson_ImagePolicyV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ImagePolicyV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImagePolicyV1Beta2Props = {}) {
    super(scope, id, {
      ...ImagePolicyV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImagePolicyV1Beta2.GVK,
      ...toJson_ImagePolicyV1Beta2Props(resolved),
    };
  }
}

/**
 * ImagePolicy is the Schema for the imagepolicies API
 *
 * @schema ImagePolicyV1Beta2
 */
export interface ImagePolicyV1Beta2Props {
  /**
   * @schema ImagePolicyV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImagePolicySpec defines the parameters for calculating the ImagePolicy.
   *
   * @schema ImagePolicyV1Beta2#spec
   */
  readonly spec?: ImagePolicyV1Beta2Spec;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2Props(obj: ImagePolicyV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImagePolicyV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImagePolicySpec defines the parameters for calculating the ImagePolicy.
 *
 * @schema ImagePolicyV1Beta2Spec
 */
export interface ImagePolicyV1Beta2Spec {
  /**
   * FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
   *
   * @schema ImagePolicyV1Beta2Spec#filterTags
   */
  readonly filterTags?: ImagePolicyV1Beta2SpecFilterTags;

  /**
   * ImageRepositoryRef points at the object specifying the image being scanned
   *
   * @schema ImagePolicyV1Beta2Spec#imageRepositoryRef
   */
  readonly imageRepositoryRef: ImagePolicyV1Beta2SpecImageRepositoryRef;

  /**
   * Policy gives the particulars of the policy to be followed in selecting the most recent image
   *
   * @schema ImagePolicyV1Beta2Spec#policy
   */
  readonly policy: ImagePolicyV1Beta2SpecPolicy;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2Spec(obj: ImagePolicyV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterTags': toJson_ImagePolicyV1Beta2SpecFilterTags(obj.filterTags),
    'imageRepositoryRef': toJson_ImagePolicyV1Beta2SpecImageRepositoryRef(obj.imageRepositoryRef),
    'policy': toJson_ImagePolicyV1Beta2SpecPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
 *
 * @schema ImagePolicyV1Beta2SpecFilterTags
 */
export interface ImagePolicyV1Beta2SpecFilterTags {
  /**
   * Extract allows a capture group to be extracted from the specified regular expression pattern, useful before tag evaluation.
   *
   * @schema ImagePolicyV1Beta2SpecFilterTags#extract
   */
  readonly extract?: string;

  /**
   * Pattern specifies a regular expression pattern used to filter for image tags.
   *
   * @schema ImagePolicyV1Beta2SpecFilterTags#pattern
   */
  readonly pattern?: string;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecFilterTags' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecFilterTags(obj: ImagePolicyV1Beta2SpecFilterTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': obj.extract,
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRepositoryRef points at the object specifying the image being scanned
 *
 * @schema ImagePolicyV1Beta2SpecImageRepositoryRef
 */
export interface ImagePolicyV1Beta2SpecImageRepositoryRef {
  /**
   * Name of the referent.
   *
   * @schema ImagePolicyV1Beta2SpecImageRepositoryRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, when not specified it acts as LocalObjectReference.
   *
   * @schema ImagePolicyV1Beta2SpecImageRepositoryRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecImageRepositoryRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecImageRepositoryRef(obj: ImagePolicyV1Beta2SpecImageRepositoryRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policy gives the particulars of the policy to be followed in selecting the most recent image
 *
 * @schema ImagePolicyV1Beta2SpecPolicy
 */
export interface ImagePolicyV1Beta2SpecPolicy {
  /**
   * Alphabetical set of rules to use for alphabetical ordering of the tags.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#alphabetical
   */
  readonly alphabetical?: ImagePolicyV1Beta2SpecPolicyAlphabetical;

  /**
   * Numerical set of rules to use for numerical ordering of the tags.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#numerical
   */
  readonly numerical?: ImagePolicyV1Beta2SpecPolicyNumerical;

  /**
   * SemVer gives a semantic version range to check against the tags available.
   *
   * @schema ImagePolicyV1Beta2SpecPolicy#semver
   */
  readonly semver?: ImagePolicyV1Beta2SpecPolicySemver;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicy(obj: ImagePolicyV1Beta2SpecPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alphabetical': toJson_ImagePolicyV1Beta2SpecPolicyAlphabetical(obj.alphabetical),
    'numerical': toJson_ImagePolicyV1Beta2SpecPolicyNumerical(obj.numerical),
    'semver': toJson_ImagePolicyV1Beta2SpecPolicySemver(obj.semver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Alphabetical set of rules to use for alphabetical ordering of the tags.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyAlphabetical
 */
export interface ImagePolicyV1Beta2SpecPolicyAlphabetical {
  /**
   * Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
   *
   * @schema ImagePolicyV1Beta2SpecPolicyAlphabetical#order
   */
  readonly order?: ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicyAlphabetical' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicyAlphabetical(obj: ImagePolicyV1Beta2SpecPolicyAlphabetical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Numerical set of rules to use for numerical ordering of the tags.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyNumerical
 */
export interface ImagePolicyV1Beta2SpecPolicyNumerical {
  /**
   * Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
   *
   * @schema ImagePolicyV1Beta2SpecPolicyNumerical#order
   */
  readonly order?: ImagePolicyV1Beta2SpecPolicyNumericalOrder;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicyNumerical' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicyNumerical(obj: ImagePolicyV1Beta2SpecPolicyNumerical | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'order': obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SemVer gives a semantic version range to check against the tags available.
 *
 * @schema ImagePolicyV1Beta2SpecPolicySemver
 */
export interface ImagePolicyV1Beta2SpecPolicySemver {
  /**
   * Range gives a semver range for the image tag; the highest version within the range that's a tag yields the latest image.
   *
   * @schema ImagePolicyV1Beta2SpecPolicySemver#range
   */
  readonly range: string;

}

/**
 * Converts an object of type 'ImagePolicyV1Beta2SpecPolicySemver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImagePolicyV1Beta2SpecPolicySemver(obj: ImagePolicyV1Beta2SpecPolicySemver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder
 */
export enum ImagePolicyV1Beta2SpecPolicyAlphabeticalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}

/**
 * Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
 *
 * @schema ImagePolicyV1Beta2SpecPolicyNumericalOrder
 */
export enum ImagePolicyV1Beta2SpecPolicyNumericalOrder {
  /** asc */
  ASC = "asc",
  /** desc */
  DESC = "desc",
}


/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepository
 */
export class ImageRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta1',
    kind: 'ImageRepository',
  }

  /**
   * Renders a Kubernetes manifest for "ImageRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageRepositoryProps = {}): any {
    return {
      ...ImageRepository.GVK,
      ...toJson_ImageRepositoryProps(props),
    };
  }

  /**
   * Defines a "ImageRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageRepositoryProps = {}) {
    super(scope, id, {
      ...ImageRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageRepository.GVK,
      ...toJson_ImageRepositoryProps(resolved),
    };
  }
}

/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepository
 */
export interface ImageRepositoryProps {
  /**
   * @schema ImageRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
   *
   * @schema ImageRepository#spec
   */
  readonly spec?: ImageRepositorySpec;

}

/**
 * Converts an object of type 'ImageRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryProps(obj: ImageRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
 *
 * @schema ImageRepositorySpec
 */
export interface ImageRepositorySpec {
  /**
   * AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
   *
   * @schema ImageRepositorySpec#accessFrom
   */
  readonly accessFrom?: ImageRepositorySpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a secret containing either or both of
   * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
   * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
   *
   * @schema ImageRepositorySpec#certSecretRef
   */
  readonly certSecretRef?: ImageRepositorySpecCertSecretRef;

  /**
   * ExclusionList is a list of regex strings used to exclude certain tags from being stored in the database.
   *
   * @schema ImageRepositorySpec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * Image is the name of the image repository
   *
   * @schema ImageRepositorySpec#image
   */
  readonly image?: string;

  /**
   * Interval is the length of time to wait between scans of the image repository.
   *
   * @schema ImageRepositorySpec#interval
   */
  readonly interval?: string;

  /**
   * SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
   *
   * @schema ImageRepositorySpec#secretRef
   */
  readonly secretRef?: ImageRepositorySpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate the image pull if the service account has attached pull secrets.
   *
   * @schema ImageRepositorySpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend subsequent image scans. It does not apply to already started scans. Defaults to false.
   *
   * @default false.
   * @schema ImageRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for image scanning. Defaults to 'Interval' duration.
   *
   * @default Interval' duration.
   * @schema ImageRepositorySpec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'ImageRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositorySpec(obj: ImageRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_ImageRepositorySpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_ImageRepositorySpecCertSecretRef(obj.certSecretRef),
    'exclusionList': obj.exclusionList?.map(y => y),
    'image': obj.image,
    'interval': obj.interval,
    'secretRef': toJson_ImageRepositorySpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
 *
 * @schema ImageRepositorySpecAccessFrom
 */
export interface ImageRepositorySpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema ImageRepositorySpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: ImageRepositorySpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'ImageRepositorySpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositorySpecAccessFrom(obj: ImageRepositorySpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ImageRepositorySpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertSecretRef can be given the name of a secret containing either or both of
 * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
 * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
 *
 * @schema ImageRepositorySpecCertSecretRef
 */
export interface ImageRepositorySpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositorySpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageRepositorySpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositorySpecCertSecretRef(obj: ImageRepositorySpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
 *
 * @schema ImageRepositorySpecSecretRef
 */
export interface ImageRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositorySpecSecretRef(obj: ImageRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema ImageRepositorySpecAccessFromNamespaceSelectors
 */
export interface ImageRepositorySpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageRepositorySpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageRepositorySpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositorySpecAccessFromNamespaceSelectors(obj: ImageRepositorySpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepositoryV1Beta2
 */
export class ImageRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta2',
    kind: 'ImageRepository',
  }

  /**
   * Renders a Kubernetes manifest for "ImageRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageRepositoryV1Beta2Props = {}): any {
    return {
      ...ImageRepositoryV1Beta2.GVK,
      ...toJson_ImageRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "ImageRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...ImageRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageRepositoryV1Beta2.GVK,
      ...toJson_ImageRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * ImageRepository is the Schema for the imagerepositories API
 *
 * @schema ImageRepositoryV1Beta2
 */
export interface ImageRepositoryV1Beta2Props {
  /**
   * @schema ImageRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
   *
   * @schema ImageRepositoryV1Beta2#spec
   */
  readonly spec?: ImageRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2Props(obj: ImageRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
 *
 * @schema ImageRepositoryV1Beta2Spec
 */
export interface ImageRepositoryV1Beta2Spec {
  /**
   * AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
   *
   * @schema ImageRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: ImageRepositoryV1Beta2SpecAccessFrom;

  /**
   * CertSecretRef can be given the name of a secret containing either or both of
   * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
   * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
   *
   * @schema ImageRepositoryV1Beta2Spec#certSecretRef
   */
  readonly certSecretRef?: ImageRepositoryV1Beta2SpecCertSecretRef;

  /**
   * ExclusionList is a list of regex strings used to exclude certain tags from being stored in the database.
   *
   * @schema ImageRepositoryV1Beta2Spec#exclusionList
   */
  readonly exclusionList?: string[];

  /**
   * Image is the name of the image repository
   *
   * @schema ImageRepositoryV1Beta2Spec#image
   */
  readonly image?: string;

  /**
   * Interval is the length of time to wait between scans of the image repository.
   *
   * @schema ImageRepositoryV1Beta2Spec#interval
   */
  readonly interval?: string;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. When not specified, defaults to 'generic'.
   *
   * @schema ImageRepositoryV1Beta2Spec#provider
   */
  readonly provider?: ImageRepositoryV1Beta2SpecProvider;

  /**
   * SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
   *
   * @schema ImageRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: ImageRepositoryV1Beta2SpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate the image pull if the service account has attached pull secrets.
   *
   * @schema ImageRepositoryV1Beta2Spec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend subsequent image scans. It does not apply to already started scans. Defaults to false.
   *
   * @default false.
   * @schema ImageRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for image scanning. Defaults to 'Interval' duration.
   *
   * @default Interval' duration.
   * @schema ImageRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2Spec(obj: ImageRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_ImageRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'certSecretRef': toJson_ImageRepositoryV1Beta2SpecCertSecretRef(obj.certSecretRef),
    'exclusionList': obj.exclusionList?.map(y => y),
    'image': obj.image,
    'interval': obj.interval,
    'provider': obj.provider,
    'secretRef': toJson_ImageRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
 *
 * @schema ImageRepositoryV1Beta2SpecAccessFrom
 */
export interface ImageRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema ImageRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2SpecAccessFrom(obj: ImageRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertSecretRef can be given the name of a secret containing either or both of
 * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
 * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
 *
 * @schema ImageRepositoryV1Beta2SpecCertSecretRef
 */
export interface ImageRepositoryV1Beta2SpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositoryV1Beta2SpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2SpecCertSecretRef(obj: ImageRepositoryV1Beta2SpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. When not specified, defaults to 'generic'.
 *
 * @schema ImageRepositoryV1Beta2SpecProvider
 */
export enum ImageRepositoryV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
 *
 * @schema ImageRepositoryV1Beta2SpecSecretRef
 */
export interface ImageRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2SpecSecretRef(obj: ImageRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: ImageRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomation
 */
export class ImageUpdateAutomation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ImageUpdateAutomation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'image.toolkit.fluxcd.io/v1beta1',
    kind: 'ImageUpdateAutomation',
  }

  /**
   * Renders a Kubernetes manifest for "ImageUpdateAutomation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ImageUpdateAutomationProps = {}): any {
    return {
      ...ImageUpdateAutomation.GVK,
      ...toJson_ImageUpdateAutomationProps(props),
    };
  }

  /**
   * Defines a "ImageUpdateAutomation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ImageUpdateAutomationProps = {}) {
    super(scope, id, {
      ...ImageUpdateAutomation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ImageUpdateAutomation.GVK,
      ...toJson_ImageUpdateAutomationProps(resolved),
    };
  }
}

/**
 * ImageUpdateAutomation is the Schema for the imageupdateautomations API
 *
 * @schema ImageUpdateAutomation
 */
export interface ImageUpdateAutomationProps {
  /**
   * @schema ImageUpdateAutomation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
   *
   * @schema ImageUpdateAutomation#spec
   */
  readonly spec?: ImageUpdateAutomationSpec;

}

/**
 * Converts an object of type 'ImageUpdateAutomationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationProps(obj: ImageUpdateAutomationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ImageUpdateAutomationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
 *
 * @schema ImageUpdateAutomationSpec
 */
export interface ImageUpdateAutomationSpec {
  /**
   * GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
   *
   * @schema ImageUpdateAutomationSpec#git
   */
  readonly git?: ImageUpdateAutomationSpecGit;

  /**
   * Interval gives an lower bound for how often the automation run should be attempted.
   *
   * @schema ImageUpdateAutomationSpec#interval
   */
  readonly interval: string;

  /**
   * SourceRef refers to the resource giving access details to a git repository.
   *
   * @schema ImageUpdateAutomationSpec#sourceRef
   */
  readonly sourceRef: ImageUpdateAutomationSpecSourceRef;

  /**
   * Suspend tells the controller to not run this automation, until it is unset (or set to false). Defaults to false.
   *
   * @default false.
   * @schema ImageUpdateAutomationSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
   *
   * @schema ImageUpdateAutomationSpec#update
   */
  readonly update?: ImageUpdateAutomationSpecUpdate;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpec(obj: ImageUpdateAutomationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'git': toJson_ImageUpdateAutomationSpecGit(obj.git),
    'interval': obj.interval,
    'sourceRef': toJson_ImageUpdateAutomationSpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'update': toJson_ImageUpdateAutomationSpecUpdate(obj.update),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
 *
 * @schema ImageUpdateAutomationSpecGit
 */
export interface ImageUpdateAutomationSpecGit {
  /**
   * Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
   *
   * @schema ImageUpdateAutomationSpecGit#checkout
   */
  readonly checkout?: ImageUpdateAutomationSpecGitCheckout;

  /**
   * Commit specifies how to commit to the git repository.
   *
   * @schema ImageUpdateAutomationSpecGit#commit
   */
  readonly commit: ImageUpdateAutomationSpecGitCommit;

  /**
   * Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
   *
   * @schema ImageUpdateAutomationSpecGit#push
   */
  readonly push?: ImageUpdateAutomationSpecGitPush;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGit(obj: ImageUpdateAutomationSpecGit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkout': toJson_ImageUpdateAutomationSpecGitCheckout(obj.checkout),
    'commit': toJson_ImageUpdateAutomationSpecGitCommit(obj.commit),
    'push': toJson_ImageUpdateAutomationSpecGitPush(obj.push),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SourceRef refers to the resource giving access details to a git repository.
 *
 * @schema ImageUpdateAutomationSpecSourceRef
 */
export interface ImageUpdateAutomationSpecSourceRef {
  /**
   * API version of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#kind
   */
  readonly kind: ImageUpdateAutomationSpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#name
   */
  readonly name: string;

  /**
   * Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
   *
   * @schema ImageUpdateAutomationSpecSourceRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecSourceRef(obj: ImageUpdateAutomationSpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
 *
 * @schema ImageUpdateAutomationSpecUpdate
 */
export interface ImageUpdateAutomationSpecUpdate {
  /**
   * Path to the directory containing the manifests to be updated. Defaults to 'None', which translates to the root path of the GitRepositoryRef.
   *
   * @default None', which translates to the root path of the GitRepositoryRef.
   * @schema ImageUpdateAutomationSpecUpdate#path
   */
  readonly path?: string;

  /**
   * Strategy names the strategy to be used.
   *
   * @schema ImageUpdateAutomationSpecUpdate#strategy
   */
  readonly strategy: ImageUpdateAutomationSpecUpdateStrategy;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecUpdate(obj: ImageUpdateAutomationSpecUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'strategy': obj.strategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
 *
 * @schema ImageUpdateAutomationSpecGitCheckout
 */
export interface ImageUpdateAutomationSpecGitCheckout {
  /**
   * Reference gives a branch, tag or commit to clone from the Git repository.
   *
   * @schema ImageUpdateAutomationSpecGitCheckout#ref
   */
  readonly ref: ImageUpdateAutomationSpecGitCheckoutRef;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCheckout' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCheckout(obj: ImageUpdateAutomationSpecGitCheckout | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_ImageUpdateAutomationSpecGitCheckoutRef(obj.ref),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Commit specifies how to commit to the git repository.
 *
 * @schema ImageUpdateAutomationSpecGitCommit
 */
export interface ImageUpdateAutomationSpecGitCommit {
  /**
   * Author gives the email and optionally the name to use as the author of commits.
   *
   * @schema ImageUpdateAutomationSpecGitCommit#author
   */
  readonly author: ImageUpdateAutomationSpecGitCommitAuthor;

  /**
   * MessageTemplate provides a template for the commit message, into which will be interpolated the details of the change made.
   *
   * @schema ImageUpdateAutomationSpecGitCommit#messageTemplate
   */
  readonly messageTemplate?: string;

  /**
   * SigningKey provides the option to sign commits with a GPG key
   *
   * @schema ImageUpdateAutomationSpecGitCommit#signingKey
   */
  readonly signingKey?: ImageUpdateAutomationSpecGitCommitSigningKey;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommit(obj: ImageUpdateAutomationSpecGitCommit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'author': toJson_ImageUpdateAutomationSpecGitCommitAuthor(obj.author),
    'messageTemplate': obj.messageTemplate,
    'signingKey': toJson_ImageUpdateAutomationSpecGitCommitSigningKey(obj.signingKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
 *
 * @schema ImageUpdateAutomationSpecGitPush
 */
export interface ImageUpdateAutomationSpecGitPush {
  /**
   * Branch specifies that commits should be pushed to the branch named. The branch is created using `.spec.checkout.branch` as the starting point, if it doesn't already exist.
   *
   * @schema ImageUpdateAutomationSpecGitPush#branch
   */
  readonly branch: string;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitPush' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitPush(obj: ImageUpdateAutomationSpecGitPush | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent.
 *
 * @schema ImageUpdateAutomationSpecSourceRefKind
 */
export enum ImageUpdateAutomationSpecSourceRefKind {
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
}

/**
 * Strategy names the strategy to be used.
 *
 * @schema ImageUpdateAutomationSpecUpdateStrategy
 */
export enum ImageUpdateAutomationSpecUpdateStrategy {
  /** Setters */
  SETTERS = "Setters",
}

/**
 * Reference gives a branch, tag or commit to clone from the Git repository.
 *
 * @schema ImageUpdateAutomationSpecGitCheckoutRef
 */
export interface ImageUpdateAutomationSpecGitCheckoutRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   * This can be combined with Branch to shallow clone the branch, in which the commit is expected to exist.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema ImageUpdateAutomationSpecGitCheckoutRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCheckoutRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCheckoutRef(obj: ImageUpdateAutomationSpecGitCheckoutRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Author gives the email and optionally the name to use as the author of commits.
 *
 * @schema ImageUpdateAutomationSpecGitCommitAuthor
 */
export interface ImageUpdateAutomationSpecGitCommitAuthor {
  /**
   * Email gives the email to provide when making a commit.
   *
   * @schema ImageUpdateAutomationSpecGitCommitAuthor#email
   */
  readonly email: string;

  /**
   * Name gives the name to provide when making a commit.
   *
   * @schema ImageUpdateAutomationSpecGitCommitAuthor#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitAuthor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitAuthor(obj: ImageUpdateAutomationSpecGitCommitAuthor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'email': obj.email,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SigningKey provides the option to sign commits with a GPG key
 *
 * @schema ImageUpdateAutomationSpecGitCommitSigningKey
 */
export interface ImageUpdateAutomationSpecGitCommitSigningKey {
  /**
   * SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
   *
   * @schema ImageUpdateAutomationSpecGitCommitSigningKey#secretRef
   */
  readonly secretRef?: ImageUpdateAutomationSpecGitCommitSigningKeySecretRef;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitSigningKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitSigningKey(obj: ImageUpdateAutomationSpecGitCommitSigningKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ImageUpdateAutomationSpecGitCommitSigningKeySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
 *
 * @schema ImageUpdateAutomationSpecGitCommitSigningKeySecretRef
 */
export interface ImageUpdateAutomationSpecGitCommitSigningKeySecretRef {
  /**
   * Name of the referent.
   *
   * @schema ImageUpdateAutomationSpecGitCommitSigningKeySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ImageUpdateAutomationSpecGitCommitSigningKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ImageUpdateAutomationSpecGitCommitSigningKeySecretRef(obj: ImageUpdateAutomationSpecGitCommitSigningKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

