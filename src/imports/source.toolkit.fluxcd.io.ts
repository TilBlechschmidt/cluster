// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Bucket is the Schema for the buckets API
 *
 * @schema Bucket
 */
export class Bucket extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Bucket"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "Bucket".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketProps = {}): any {
    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(props),
    };
  }

  /**
   * Defines a "Bucket" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketProps = {}) {
    super(scope, id, {
      ...Bucket.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Bucket.GVK,
      ...toJson_BucketProps(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API
 *
 * @schema Bucket
 */
export interface BucketProps {
  /**
   * @schema Bucket#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec defines the desired state of an S3 compatible bucket
   *
   * @schema Bucket#spec
   */
  readonly spec?: BucketSpec;

}

/**
 * Converts an object of type 'BucketProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketProps(obj: BucketProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec defines the desired state of an S3 compatible bucket
 *
 * @schema BucketSpec
 */
export interface BucketSpec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema BucketSpec#accessFrom
   */
  readonly accessFrom?: BucketSpecAccessFrom;

  /**
   * The bucket name.
   *
   * @schema BucketSpec#bucketName
   */
  readonly bucketName: string;

  /**
   * The bucket endpoint address.
   *
   * @schema BucketSpec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema BucketSpec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS S3 HTTP endpoint.
   *
   * @schema BucketSpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * The interval at which to check for bucket updates.
   *
   * @schema BucketSpec#interval
   */
  readonly interval: string;

  /**
   * The S3 compatible storage provider name, default ('generic').
   *
   * @schema BucketSpec#provider
   */
  readonly provider?: BucketSpecProvider;

  /**
   * The bucket region.
   *
   * @schema BucketSpec#region
   */
  readonly region?: string;

  /**
   * The name of the secret containing authentication credentials for the Bucket.
   *
   * @schema BucketSpec#secretRef
   */
  readonly secretRef?: BucketSpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema BucketSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for download operations, defaults to 60s.
   *
   * @schema BucketSpec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpec(obj: BucketSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_BucketSpecAccessFrom(obj.accessFrom),
    'bucketName': obj.bucketName,
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'region': obj.region,
    'secretRef': toJson_BucketSpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema BucketSpecAccessFrom
 */
export interface BucketSpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema BucketSpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: BucketSpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'BucketSpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAccessFrom(obj: BucketSpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_BucketSpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The S3 compatible storage provider name, default ('generic').
 *
 * @schema BucketSpecProvider
 */
export enum BucketSpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
}

/**
 * The name of the secret containing authentication credentials for the Bucket.
 *
 * @schema BucketSpecSecretRef
 */
export interface BucketSpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketSpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketSpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecSecretRef(obj: BucketSpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema BucketSpecAccessFromNamespaceSelectors
 */
export interface BucketSpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BucketSpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketSpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketSpecAccessFromNamespaceSelectors(obj: BucketSpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema BucketV1Beta2
 */
export class BucketV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BucketV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'Bucket',
  }

  /**
   * Renders a Kubernetes manifest for "BucketV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BucketV1Beta2Props = {}): any {
    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(props),
    };
  }

  /**
   * Defines a "BucketV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BucketV1Beta2Props = {}) {
    super(scope, id, {
      ...BucketV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BucketV1Beta2.GVK,
      ...toJson_BucketV1Beta2Props(resolved),
    };
  }
}

/**
 * Bucket is the Schema for the buckets API.
 *
 * @schema BucketV1Beta2
 */
export interface BucketV1Beta2Props {
  /**
   * @schema BucketV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BucketSpec specifies the required configuration to produce an Artifact for an object storage bucket.
   *
   * @schema BucketV1Beta2#spec
   */
  readonly spec?: BucketV1Beta2Spec;

}

/**
 * Converts an object of type 'BucketV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketV1Beta2Props(obj: BucketV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BucketV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BucketSpec specifies the required configuration to produce an Artifact for an object storage bucket.
 *
 * @schema BucketV1Beta2Spec
 */
export interface BucketV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema BucketV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: BucketV1Beta2SpecAccessFrom;

  /**
   * BucketName is the name of the object storage bucket.
   *
   * @schema BucketV1Beta2Spec#bucketName
   */
  readonly bucketName: string;

  /**
   * Endpoint is the object storage address the BucketName is located at.
   *
   * @schema BucketV1Beta2Spec#endpoint
   */
  readonly endpoint: string;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema BucketV1Beta2Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP Endpoint.
   *
   * @schema BucketV1Beta2Spec#insecure
   */
  readonly insecure?: boolean;

  /**
   * Interval at which to check the Endpoint for updates.
   *
   * @schema BucketV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * Provider of the object storage bucket. Defaults to 'generic', which expects an S3 (API) compatible object storage.
   *
   * @default generic', which expects an S3 (API) compatible object storage.
   * @schema BucketV1Beta2Spec#provider
   */
  readonly provider?: BucketV1Beta2SpecProvider;

  /**
   * Region of the Endpoint where the BucketName is located in.
   *
   * @schema BucketV1Beta2Spec#region
   */
  readonly region?: string;

  /**
   * SecretRef specifies the Secret containing authentication credentials for the Bucket.
   *
   * @schema BucketV1Beta2Spec#secretRef
   */
  readonly secretRef?: BucketV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this Bucket.
   *
   * @schema BucketV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for fetch operations, defaults to 60s.
   *
   * @schema BucketV1Beta2Spec#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'BucketV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketV1Beta2Spec(obj: BucketV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_BucketV1Beta2SpecAccessFrom(obj.accessFrom),
    'bucketName': obj.bucketName,
    'endpoint': obj.endpoint,
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'provider': obj.provider,
    'region': obj.region,
    'secretRef': toJson_BucketV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema BucketV1Beta2SpecAccessFrom
 */
export interface BucketV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema BucketV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: BucketV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'BucketV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketV1Beta2SpecAccessFrom(obj: BucketV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_BucketV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Provider of the object storage bucket. Defaults to 'generic', which expects an S3 (API) compatible object storage.
 *
 * @default generic', which expects an S3 (API) compatible object storage.
 * @schema BucketV1Beta2SpecProvider
 */
export enum BucketV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** gcp */
  GCP = "gcp",
  /** azure */
  AZURE = "azure",
}

/**
 * SecretRef specifies the Secret containing authentication credentials for the Bucket.
 *
 * @schema BucketV1Beta2SpecSecretRef
 */
export interface BucketV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema BucketV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BucketV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketV1Beta2SpecSecretRef(obj: BucketV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema BucketV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface BucketV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema BucketV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'BucketV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BucketV1Beta2SpecAccessFromNamespaceSelectors(obj: BucketV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepository
 */
export class GitRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryProps = {}): any {
    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(props),
    };
  }

  /**
   * Defines a "GitRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryProps = {}) {
    super(scope, id, {
      ...GitRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepository
 */
export interface GitRepositoryProps {
  /**
   * @schema GitRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec specifies the required configuration to produce an Artifact for a Git repository.
   *
   * @schema GitRepository#spec
   */
  readonly spec?: GitRepositorySpec;

}

/**
 * Converts an object of type 'GitRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryProps(obj: GitRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositorySpec specifies the required configuration to produce an Artifact for a Git repository.
 *
 * @schema GitRepositorySpec
 */
export interface GitRepositorySpec {
  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositorySpec#ignore
   */
  readonly ignore?: string;

  /**
   * Include specifies a list of GitRepository resources which Artifacts should be included in the Artifact produced for this GitRepository.
   *
   * @schema GitRepositorySpec#include
   */
  readonly include?: GitRepositorySpecInclude[];

  /**
   * Interval at which to check the GitRepository for updates.
   *
   * @schema GitRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * RecurseSubmodules enables the initialization of all submodules within the GitRepository as cloned from the URL, using their default settings.
   *
   * @schema GitRepositorySpec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
   *
   * @schema GitRepositorySpec#ref
   */
  readonly ref?: GitRepositorySpecRef;

  /**
   * SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields for basic auth or 'bearerToken' field for token auth. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
   *
   * @schema GitRepositorySpec#secretRef
   */
  readonly secretRef?: GitRepositorySpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this GitRepository.
   *
   * @schema GitRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
   *
   * @schema GitRepositorySpec#url
   */
  readonly url: string;

  /**
   * Verification specifies the configuration to verify the Git commit signature(s).
   *
   * @schema GitRepositorySpec#verify
   */
  readonly verify?: GitRepositorySpecVerify;

}

/**
 * Converts an object of type 'GitRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpec(obj: GitRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositorySpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositorySpecRef(obj.ref),
    'secretRef': toJson_GitRepositorySpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositorySpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositoryInclude specifies a local reference to a GitRepository which Artifact (sub-)contents must be included, and where they should be placed.
 *
 * @schema GitRepositorySpecInclude
 */
export interface GitRepositorySpecInclude {
  /**
   * FromPath specifies the path to copy contents from, defaults to the root of the Artifact.
   *
   * @schema GitRepositorySpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
   *
   * @schema GitRepositorySpecInclude#repository
   */
  readonly repository: GitRepositorySpecIncludeRepository;

  /**
   * ToPath specifies the path to copy contents to, defaults to the name of the GitRepositoryRef.
   *
   * @schema GitRepositorySpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecInclude(obj: GitRepositorySpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositorySpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
 *
 * @schema GitRepositorySpecRef
 */
export interface GitRepositorySpecRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema GitRepositorySpecRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   * This can be combined with Branch to shallow clone the branch, in which the commit is expected to exist.
   *
   * @schema GitRepositorySpecRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema GitRepositorySpecRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema GitRepositorySpecRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema GitRepositorySpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositorySpecRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecRef(obj: GitRepositorySpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields for basic auth or 'bearerToken' field for token auth. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
 *
 * @schema GitRepositorySpecSecretRef
 */
export interface GitRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecSecretRef(obj: GitRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verification specifies the configuration to verify the Git commit signature(s).
 *
 * @schema GitRepositorySpecVerify
 */
export interface GitRepositorySpecVerify {
  /**
   * Mode specifies what Git object should be verified, currently ('head').
   *
   * @schema GitRepositorySpecVerify#mode
   */
  readonly mode: GitRepositorySpecVerifyMode;

  /**
   * SecretRef specifies the Secret containing the public keys of trusted Git authors.
   *
   * @schema GitRepositorySpecVerify#secretRef
   */
  readonly secretRef: GitRepositorySpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositorySpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecVerify(obj: GitRepositorySpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositorySpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
 *
 * @schema GitRepositorySpecIncludeRepository
 */
export interface GitRepositorySpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecIncludeRepository(obj: GitRepositorySpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode specifies what Git object should be verified, currently ('head').
 *
 * @schema GitRepositorySpecVerifyMode
 */
export enum GitRepositorySpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * SecretRef specifies the Secret containing the public keys of trusted Git authors.
 *
 * @schema GitRepositorySpecVerifySecretRef
 */
export interface GitRepositorySpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositorySpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositorySpecVerifySecretRef(obj: GitRepositorySpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepositoryV1Beta1
 */
export class GitRepositoryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepositoryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepositoryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryV1Beta1Props = {}): any {
    return {
      ...GitRepositoryV1Beta1.GVK,
      ...toJson_GitRepositoryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "GitRepositoryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryV1Beta1Props = {}) {
    super(scope, id, {
      ...GitRepositoryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepositoryV1Beta1.GVK,
      ...toJson_GitRepositoryV1Beta1Props(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API
 *
 * @schema GitRepositoryV1Beta1
 */
export interface GitRepositoryV1Beta1Props {
  /**
   * @schema GitRepositoryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec defines the desired state of a Git repository.
   *
   * @schema GitRepositoryV1Beta1#spec
   */
  readonly spec?: GitRepositoryV1Beta1Spec;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1Props(obj: GitRepositoryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositoryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositorySpec defines the desired state of a Git repository.
 *
 * @schema GitRepositoryV1Beta1Spec
 */
export interface GitRepositoryV1Beta1Spec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema GitRepositoryV1Beta1Spec#accessFrom
   */
  readonly accessFrom?: GitRepositoryV1Beta1SpecAccessFrom;

  /**
   * Determines which git client library to use. Defaults to go-git, valid values are ('go-git', 'libgit2').
   *
   * @default go-git, valid values are ('go-git', 'libgit2').
   * @schema GitRepositoryV1Beta1Spec#gitImplementation
   */
  readonly gitImplementation?: GitRepositoryV1Beta1SpecGitImplementation;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositoryV1Beta1Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Extra git repositories to map into the repository
   *
   * @schema GitRepositoryV1Beta1Spec#include
   */
  readonly include?: GitRepositoryV1Beta1SpecInclude[];

  /**
   * The interval at which to check for repository updates.
   *
   * @schema GitRepositoryV1Beta1Spec#interval
   */
  readonly interval: string;

  /**
   * When enabled, after the clone is created, initializes all submodules within, using their default settings. This option is available only when using the 'go-git' GitImplementation.
   *
   * @schema GitRepositoryV1Beta1Spec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * The Git reference to checkout and monitor for changes, defaults to master branch.
   *
   * @schema GitRepositoryV1Beta1Spec#ref
   */
  readonly ref?: GitRepositoryV1Beta1SpecRef;

  /**
   * The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity and known_hosts fields.
   *
   * @schema GitRepositoryV1Beta1Spec#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta1SpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema GitRepositoryV1Beta1Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositoryV1Beta1Spec#timeout
   */
  readonly timeout?: string;

  /**
   * The repository URL, can be a HTTP/S or SSH address.
   *
   * @schema GitRepositoryV1Beta1Spec#url
   */
  readonly url: string;

  /**
   * Verify OpenPGP signature for the Git commit HEAD points to.
   *
   * @schema GitRepositoryV1Beta1Spec#verify
   */
  readonly verify?: GitRepositoryV1Beta1SpecVerify;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1Spec(obj: GitRepositoryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_GitRepositoryV1Beta1SpecAccessFrom(obj.accessFrom),
    'gitImplementation': obj.gitImplementation,
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositoryV1Beta1SpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositoryV1Beta1SpecRef(obj.ref),
    'secretRef': toJson_GitRepositoryV1Beta1SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositoryV1Beta1SpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema GitRepositoryV1Beta1SpecAccessFrom
 */
export interface GitRepositoryV1Beta1SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema GitRepositoryV1Beta1SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecAccessFrom(obj: GitRepositoryV1Beta1SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines which git client library to use. Defaults to go-git, valid values are ('go-git', 'libgit2').
 *
 * @default go-git, valid values are ('go-git', 'libgit2').
 * @schema GitRepositoryV1Beta1SpecGitImplementation
 */
export enum GitRepositoryV1Beta1SpecGitImplementation {
  /** go-git */
  GO_GIT = "go-git",
  /** libgit2 */
  LIBGIT2 = "libgit2",
}

/**
 * GitRepositoryInclude defines a source with a from and to path.
 *
 * @schema GitRepositoryV1Beta1SpecInclude
 */
export interface GitRepositoryV1Beta1SpecInclude {
  /**
   * The path to copy contents from, defaults to the root directory.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * Reference to a GitRepository to include.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#repository
   */
  readonly repository: GitRepositoryV1Beta1SpecIncludeRepository;

  /**
   * The path to copy contents to, defaults to the name of the source ref.
   *
   * @schema GitRepositoryV1Beta1SpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecInclude(obj: GitRepositoryV1Beta1SpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositoryV1Beta1SpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Git reference to checkout and monitor for changes, defaults to master branch.
 *
 * @schema GitRepositoryV1Beta1SpecRef
 */
export interface GitRepositoryV1Beta1SpecRef {
  /**
   * The Git branch to checkout, defaults to master.
   *
   * @schema GitRepositoryV1Beta1SpecRef#branch
   */
  readonly branch?: string;

  /**
   * The Git commit SHA to checkout, if specified Tag filters will be ignored.
   *
   * @schema GitRepositoryV1Beta1SpecRef#commit
   */
  readonly commit?: string;

  /**
   * The Git tag semver expression, takes precedence over Tag.
   *
   * @schema GitRepositoryV1Beta1SpecRef#semver
   */
  readonly semver?: string;

  /**
   * The Git tag to checkout, takes precedence over Branch.
   *
   * @schema GitRepositoryV1Beta1SpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecRef(obj: GitRepositoryV1Beta1SpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity and known_hosts fields.
 *
 * @schema GitRepositoryV1Beta1SpecSecretRef
 */
export interface GitRepositoryV1Beta1SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecSecretRef(obj: GitRepositoryV1Beta1SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verify OpenPGP signature for the Git commit HEAD points to.
 *
 * @schema GitRepositoryV1Beta1SpecVerify
 */
export interface GitRepositoryV1Beta1SpecVerify {
  /**
   * Mode describes what git object should be verified, currently ('head').
   *
   * @schema GitRepositoryV1Beta1SpecVerify#mode
   */
  readonly mode: GitRepositoryV1Beta1SpecVerifyMode;

  /**
   * The secret name containing the public keys of all trusted Git authors.
   *
   * @schema GitRepositoryV1Beta1SpecVerify#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta1SpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecVerify(obj: GitRepositoryV1Beta1SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositoryV1Beta1SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors
 */
export interface GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors(obj: GitRepositoryV1Beta1SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GitRepository to include.
 *
 * @schema GitRepositoryV1Beta1SpecIncludeRepository
 */
export interface GitRepositoryV1Beta1SpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecIncludeRepository(obj: GitRepositoryV1Beta1SpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode describes what git object should be verified, currently ('head').
 *
 * @schema GitRepositoryV1Beta1SpecVerifyMode
 */
export enum GitRepositoryV1Beta1SpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * The secret name containing the public keys of all trusted Git authors.
 *
 * @schema GitRepositoryV1Beta1SpecVerifySecretRef
 */
export interface GitRepositoryV1Beta1SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta1SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta1SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta1SpecVerifySecretRef(obj: GitRepositoryV1Beta1SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepositoryV1Beta2
 */
export class GitRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryV1Beta2Props = {}): any {
    return {
      ...GitRepositoryV1Beta2.GVK,
      ...toJson_GitRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "GitRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...GitRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepositoryV1Beta2.GVK,
      ...toJson_GitRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * GitRepository is the Schema for the gitrepositories API.
 *
 * @schema GitRepositoryV1Beta2
 */
export interface GitRepositoryV1Beta2Props {
  /**
   * @schema GitRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GitRepositorySpec specifies the required configuration to produce an Artifact for a Git repository.
   *
   * @schema GitRepositoryV1Beta2#spec
   */
  readonly spec?: GitRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2Props(obj: GitRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositorySpec specifies the required configuration to produce an Artifact for a Git repository.
 *
 * @schema GitRepositoryV1Beta2Spec
 */
export interface GitRepositoryV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema GitRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: GitRepositoryV1Beta2SpecAccessFrom;

  /**
   * GitImplementation specifies which Git client library implementation to use. Defaults to 'go-git', valid values are ('go-git', 'libgit2'). Deprecated: gitImplementation is deprecated now that 'go-git' is the only supported implementation.
   *
   * @default go-git', valid values are ('go-git', 'libgit2'). Deprecated: gitImplementation is deprecated now that 'go-git' is the only supported implementation.
   * @schema GitRepositoryV1Beta2Spec#gitImplementation
   */
  readonly gitImplementation?: GitRepositoryV1Beta2SpecGitImplementation;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema GitRepositoryV1Beta2Spec#ignore
   */
  readonly ignore?: string;

  /**
   * Include specifies a list of GitRepository resources which Artifacts should be included in the Artifact produced for this GitRepository.
   *
   * @schema GitRepositoryV1Beta2Spec#include
   */
  readonly include?: GitRepositoryV1Beta2SpecInclude[];

  /**
   * Interval at which to check the GitRepository for updates.
   *
   * @schema GitRepositoryV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * RecurseSubmodules enables the initialization of all submodules within the GitRepository as cloned from the URL, using their default settings.
   *
   * @schema GitRepositoryV1Beta2Spec#recurseSubmodules
   */
  readonly recurseSubmodules?: boolean;

  /**
   * Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
   *
   * @schema GitRepositoryV1Beta2Spec#ref
   */
  readonly ref?: GitRepositoryV1Beta2SpecRef;

  /**
   * SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields for basic auth or 'bearerToken' field for token auth. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
   *
   * @schema GitRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: GitRepositoryV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this GitRepository.
   *
   * @schema GitRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout for Git operations like cloning, defaults to 60s.
   *
   * @schema GitRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
   *
   * @schema GitRepositoryV1Beta2Spec#url
   */
  readonly url: string;

  /**
   * Verification specifies the configuration to verify the Git commit signature(s).
   *
   * @schema GitRepositoryV1Beta2Spec#verify
   */
  readonly verify?: GitRepositoryV1Beta2SpecVerify;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2Spec(obj: GitRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_GitRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'gitImplementation': obj.gitImplementation,
    'ignore': obj.ignore,
    'include': obj.include?.map(y => toJson_GitRepositoryV1Beta2SpecInclude(y)),
    'interval': obj.interval,
    'recurseSubmodules': obj.recurseSubmodules,
    'ref': toJson_GitRepositoryV1Beta2SpecRef(obj.ref),
    'secretRef': toJson_GitRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_GitRepositoryV1Beta2SpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema GitRepositoryV1Beta2SpecAccessFrom
 */
export interface GitRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema GitRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecAccessFrom(obj: GitRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitImplementation specifies which Git client library implementation to use. Defaults to 'go-git', valid values are ('go-git', 'libgit2'). Deprecated: gitImplementation is deprecated now that 'go-git' is the only supported implementation.
 *
 * @default go-git', valid values are ('go-git', 'libgit2'). Deprecated: gitImplementation is deprecated now that 'go-git' is the only supported implementation.
 * @schema GitRepositoryV1Beta2SpecGitImplementation
 */
export enum GitRepositoryV1Beta2SpecGitImplementation {
  /** go-git */
  GO_GIT = "go-git",
  /** libgit2 */
  LIBGIT2 = "libgit2",
}

/**
 * GitRepositoryInclude specifies a local reference to a GitRepository which Artifact (sub-)contents must be included, and where they should be placed.
 *
 * @schema GitRepositoryV1Beta2SpecInclude
 */
export interface GitRepositoryV1Beta2SpecInclude {
  /**
   * FromPath specifies the path to copy contents from, defaults to the root of the Artifact.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#fromPath
   */
  readonly fromPath?: string;

  /**
   * GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#repository
   */
  readonly repository: GitRepositoryV1Beta2SpecIncludeRepository;

  /**
   * ToPath specifies the path to copy contents to, defaults to the name of the GitRepositoryRef.
   *
   * @schema GitRepositoryV1Beta2SpecInclude#toPath
   */
  readonly toPath?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecInclude(obj: GitRepositoryV1Beta2SpecInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fromPath': obj.fromPath,
    'repository': toJson_GitRepositoryV1Beta2SpecIncludeRepository(obj.repository),
    'toPath': obj.toPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
 *
 * @schema GitRepositoryV1Beta2SpecRef
 */
export interface GitRepositoryV1Beta2SpecRef {
  /**
   * Branch to check out, defaults to 'master' if no other field is defined.
   *
   * @schema GitRepositoryV1Beta2SpecRef#branch
   */
  readonly branch?: string;

  /**
   * Commit SHA to check out, takes precedence over all reference fields.
   * This can be combined with Branch to shallow clone the branch, in which the commit is expected to exist.
   *
   * @schema GitRepositoryV1Beta2SpecRef#commit
   */
  readonly commit?: string;

  /**
   * Name of the reference to check out; takes precedence over Branch, Tag and SemVer.
   * It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
   *
   * @schema GitRepositoryV1Beta2SpecRef#name
   */
  readonly name?: string;

  /**
   * SemVer tag expression to check out, takes precedence over Tag.
   *
   * @schema GitRepositoryV1Beta2SpecRef#semver
   */
  readonly semver?: string;

  /**
   * Tag to check out, takes precedence over Branch.
   *
   * @schema GitRepositoryV1Beta2SpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecRef(obj: GitRepositoryV1Beta2SpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'branch': obj.branch,
    'commit': obj.commit,
    'name': obj.name,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields for basic auth or 'bearerToken' field for token auth. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
 *
 * @schema GitRepositoryV1Beta2SpecSecretRef
 */
export interface GitRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecSecretRef(obj: GitRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verification specifies the configuration to verify the Git commit signature(s).
 *
 * @schema GitRepositoryV1Beta2SpecVerify
 */
export interface GitRepositoryV1Beta2SpecVerify {
  /**
   * Mode specifies what Git object should be verified, currently ('head').
   *
   * @schema GitRepositoryV1Beta2SpecVerify#mode
   */
  readonly mode: GitRepositoryV1Beta2SpecVerifyMode;

  /**
   * SecretRef specifies the Secret containing the public keys of trusted Git authors.
   *
   * @schema GitRepositoryV1Beta2SpecVerify#secretRef
   */
  readonly secretRef: GitRepositoryV1Beta2SpecVerifySecretRef;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecVerify(obj: GitRepositoryV1Beta2SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
    'secretRef': toJson_GitRepositoryV1Beta2SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: GitRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
 *
 * @schema GitRepositoryV1Beta2SpecIncludeRepository
 */
export interface GitRepositoryV1Beta2SpecIncludeRepository {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecIncludeRepository#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecIncludeRepository' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecIncludeRepository(obj: GitRepositoryV1Beta2SpecIncludeRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mode specifies what Git object should be verified, currently ('head').
 *
 * @schema GitRepositoryV1Beta2SpecVerifyMode
 */
export enum GitRepositoryV1Beta2SpecVerifyMode {
  /** head */
  HEAD = "head",
}

/**
 * SecretRef specifies the Secret containing the public keys of trusted Git authors.
 *
 * @schema GitRepositoryV1Beta2SpecVerifySecretRef
 */
export interface GitRepositoryV1Beta2SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema GitRepositoryV1Beta2SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositoryV1Beta2SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GitRepositoryV1Beta2SpecVerifySecretRef(obj: GitRepositoryV1Beta2SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChart
 */
export class HelmChart extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChart"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChart".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartProps = {}): any {
    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(props),
    };
  }

  /**
   * Defines a "HelmChart" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartProps = {}) {
    super(scope, id, {
      ...HelmChart.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChart.GVK,
      ...toJson_HelmChartProps(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API
 *
 * @schema HelmChart
 */
export interface HelmChartProps {
  /**
   * @schema HelmChart#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec defines the desired state of a Helm chart.
   *
   * @schema HelmChart#spec
   */
  readonly spec?: HelmChartSpec;

}

/**
 * Converts an object of type 'HelmChartProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartProps(obj: HelmChartProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmChartSpec defines the desired state of a Helm chart.
 *
 * @schema HelmChartSpec
 */
export interface HelmChartSpec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema HelmChartSpec#accessFrom
   */
  readonly accessFrom?: HelmChartSpecAccessFrom;

  /**
   * The name or path the Helm chart is available at in the SourceRef.
   *
   * @schema HelmChartSpec#chart
   */
  readonly chart: string;

  /**
   * The interval at which to check the Source for updates.
   *
   * @schema HelmChartSpec#interval
   */
  readonly interval: string;

  /**
   * Determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
   *
   * @default ChartVersion when omitted.
   * @schema HelmChartSpec#reconcileStrategy
   */
  readonly reconcileStrategy?: HelmChartSpecReconcileStrategy;

  /**
   * The reference to the Source the chart is available at.
   *
   * @schema HelmChartSpec#sourceRef
   */
  readonly sourceRef: HelmChartSpecSourceRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmChartSpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file defined here is merged before the ValuesFiles items. Ignored when omitted.
   *
   * @schema HelmChartSpec#valuesFile
   */
  readonly valuesFile?: string;

  /**
   * Alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
   *
   * @schema HelmChartSpec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartSpec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpec(obj: HelmChartSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmChartSpecAccessFrom(obj.accessFrom),
    'chart': obj.chart,
    'interval': obj.interval,
    'reconcileStrategy': obj.reconcileStrategy,
    'sourceRef': toJson_HelmChartSpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFile': obj.valuesFile,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema HelmChartSpecAccessFrom
 */
export interface HelmChartSpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmChartSpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmChartSpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmChartSpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpecAccessFrom(obj: HelmChartSpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmChartSpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
 *
 * @default ChartVersion when omitted.
 * @schema HelmChartSpecReconcileStrategy
 */
export enum HelmChartSpecReconcileStrategy {
  /** ChartVersion */
  CHART_VERSION = "ChartVersion",
  /** Revision */
  REVISION = "Revision",
}

/**
 * The reference to the Source the chart is available at.
 *
 * @schema HelmChartSpecSourceRef
 */
export interface HelmChartSpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartSpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
   *
   * @schema HelmChartSpecSourceRef#kind
   */
  readonly kind: HelmChartSpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartSpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartSpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpecSourceRef(obj: HelmChartSpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmChartSpecAccessFromNamespaceSelectors
 */
export interface HelmChartSpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmChartSpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmChartSpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartSpecAccessFromNamespaceSelectors(obj: HelmChartSpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
 *
 * @schema HelmChartSpecSourceRefKind
 */
export enum HelmChartSpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}


/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChartV1Beta2
 */
export class HelmChartV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmChartV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'HelmChart',
  }

  /**
   * Renders a Kubernetes manifest for "HelmChartV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmChartV1Beta2Props = {}): any {
    return {
      ...HelmChartV1Beta2.GVK,
      ...toJson_HelmChartV1Beta2Props(props),
    };
  }

  /**
   * Defines a "HelmChartV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmChartV1Beta2Props = {}) {
    super(scope, id, {
      ...HelmChartV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmChartV1Beta2.GVK,
      ...toJson_HelmChartV1Beta2Props(resolved),
    };
  }
}

/**
 * HelmChart is the Schema for the helmcharts API.
 *
 * @schema HelmChartV1Beta2
 */
export interface HelmChartV1Beta2Props {
  /**
   * @schema HelmChartV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmChartSpec specifies the desired state of a Helm chart.
   *
   * @schema HelmChartV1Beta2#spec
   */
  readonly spec?: HelmChartV1Beta2Spec;

}

/**
 * Converts an object of type 'HelmChartV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2Props(obj: HelmChartV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmChartV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmChartSpec specifies the desired state of a Helm chart.
 *
 * @schema HelmChartV1Beta2Spec
 */
export interface HelmChartV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema HelmChartV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: HelmChartV1Beta2SpecAccessFrom;

  /**
   * Chart is the name or path the Helm chart is available at in the SourceRef.
   *
   * @schema HelmChartV1Beta2Spec#chart
   */
  readonly chart: string;

  /**
   * Interval is the interval at which to check the Source for updates.
   *
   * @schema HelmChartV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * ReconcileStrategy determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
   *
   * @default ChartVersion when omitted.
   * @schema HelmChartV1Beta2Spec#reconcileStrategy
   */
  readonly reconcileStrategy?: HelmChartV1Beta2SpecReconcileStrategy;

  /**
   * SourceRef is the reference to the Source the chart is available at.
   *
   * @schema HelmChartV1Beta2Spec#sourceRef
   */
  readonly sourceRef: HelmChartV1Beta2SpecSourceRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmChartV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * ValuesFile is an alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file specified here is merged before the ValuesFiles items. Ignored when omitted.
   *
   * @schema HelmChartV1Beta2Spec#valuesFile
   */
  readonly valuesFile?: string;

  /**
   * ValuesFiles is an alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
   *
   * @schema HelmChartV1Beta2Spec#valuesFiles
   */
  readonly valuesFiles?: string[];

  /**
   * Verify contains the secret name containing the trusted public keys used to verify the signature and specifies which provider to use to check whether OCI image is authentic. This field is only supported when using HelmRepository source with spec.type 'oci'. Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
   *
   * @schema HelmChartV1Beta2Spec#verify
   */
  readonly verify?: HelmChartV1Beta2SpecVerify;

  /**
   * Version is the chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted.
   *
   * @default latest when omitted.
   * @schema HelmChartV1Beta2Spec#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2Spec(obj: HelmChartV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmChartV1Beta2SpecAccessFrom(obj.accessFrom),
    'chart': obj.chart,
    'interval': obj.interval,
    'reconcileStrategy': obj.reconcileStrategy,
    'sourceRef': toJson_HelmChartV1Beta2SpecSourceRef(obj.sourceRef),
    'suspend': obj.suspend,
    'valuesFile': obj.valuesFile,
    'valuesFiles': obj.valuesFiles?.map(y => y),
    'verify': toJson_HelmChartV1Beta2SpecVerify(obj.verify),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema HelmChartV1Beta2SpecAccessFrom
 */
export interface HelmChartV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmChartV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmChartV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2SpecAccessFrom(obj: HelmChartV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmChartV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReconcileStrategy determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
 *
 * @default ChartVersion when omitted.
 * @schema HelmChartV1Beta2SpecReconcileStrategy
 */
export enum HelmChartV1Beta2SpecReconcileStrategy {
  /** ChartVersion */
  CHART_VERSION = "ChartVersion",
  /** Revision */
  REVISION = "Revision",
}

/**
 * SourceRef is the reference to the Source the chart is available at.
 *
 * @schema HelmChartV1Beta2SpecSourceRef
 */
export interface HelmChartV1Beta2SpecSourceRef {
  /**
   * APIVersion of the referent.
   *
   * @schema HelmChartV1Beta2SpecSourceRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
   *
   * @schema HelmChartV1Beta2SpecSourceRef#kind
   */
  readonly kind: HelmChartV1Beta2SpecSourceRefKind;

  /**
   * Name of the referent.
   *
   * @schema HelmChartV1Beta2SpecSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2SpecSourceRef(obj: HelmChartV1Beta2SpecSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verify contains the secret name containing the trusted public keys used to verify the signature and specifies which provider to use to check whether OCI image is authentic. This field is only supported when using HelmRepository source with spec.type 'oci'. Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
 *
 * @schema HelmChartV1Beta2SpecVerify
 */
export interface HelmChartV1Beta2SpecVerify {
  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema HelmChartV1Beta2SpecVerify#provider
   */
  readonly provider: HelmChartV1Beta2SpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the trusted public keys.
   *
   * @schema HelmChartV1Beta2SpecVerify#secretRef
   */
  readonly secretRef?: HelmChartV1Beta2SpecVerifySecretRef;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2SpecVerify(obj: HelmChartV1Beta2SpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider,
    'secretRef': toJson_HelmChartV1Beta2SpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmChartV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface HelmChartV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmChartV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2SpecAccessFromNamespaceSelectors(obj: HelmChartV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
 *
 * @schema HelmChartV1Beta2SpecSourceRefKind
 */
export enum HelmChartV1Beta2SpecSourceRefKind {
  /** HelmRepository */
  HELM_REPOSITORY = "HelmRepository",
  /** GitRepository */
  GIT_REPOSITORY = "GitRepository",
  /** Bucket */
  BUCKET = "Bucket",
}

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema HelmChartV1Beta2SpecVerifyProvider
 */
export enum HelmChartV1Beta2SpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the trusted public keys.
 *
 * @schema HelmChartV1Beta2SpecVerifySecretRef
 */
export interface HelmChartV1Beta2SpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmChartV1Beta2SpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmChartV1Beta2SpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmChartV1Beta2SpecVerifySecretRef(obj: HelmChartV1Beta2SpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepository
 */
export class HelmRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta1',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryProps = {}): any {
    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(props),
    };
  }

  /**
   * Defines a "HelmRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryProps = {}) {
    super(scope, id, {
      ...HelmRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepository.GVK,
      ...toJson_HelmRepositoryProps(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API
 *
 * @schema HelmRepository
 */
export interface HelmRepositoryProps {
  /**
   * @schema HelmRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec defines the reference to a Helm repository.
   *
   * @schema HelmRepository#spec
   */
  readonly spec?: HelmRepositorySpec;

}

/**
 * Converts an object of type 'HelmRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryProps(obj: HelmRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmRepositorySpec defines the reference to a Helm repository.
 *
 * @schema HelmRepositorySpec
 */
export interface HelmRepositorySpec {
  /**
   * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
   *
   * @schema HelmRepositorySpec#accessFrom
   */
  readonly accessFrom?: HelmRepositorySpecAccessFrom;

  /**
   * The interval at which to check the upstream for updates.
   *
   * @schema HelmRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed on to a host that does not match the host as defined in URL. This may be required if the host of the advertised chart URLs in the index differ from the defined URL. Enabling this should be done with caution, as it can potentially result in credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositorySpec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caFile fields.
   *
   * @schema HelmRepositorySpec#secretRef
   */
  readonly secretRef?: HelmRepositorySpecSecretRef;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema HelmRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout of index downloading, defaults to 60s.
   *
   * @schema HelmRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * The Helm repository URL, a valid URL contains at least a protocol and host.
   *
   * @schema HelmRepositorySpec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpec(obj: HelmRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmRepositorySpecAccessFrom(obj.accessFrom),
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'secretRef': toJson_HelmRepositorySpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
 *
 * @schema HelmRepositorySpecAccessFrom
 */
export interface HelmRepositorySpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmRepositorySpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmRepositorySpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmRepositorySpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpecAccessFrom(obj: HelmRepositorySpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmRepositorySpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caFile fields.
 *
 * @schema HelmRepositorySpecSecretRef
 */
export interface HelmRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpecSecretRef(obj: HelmRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmRepositorySpecAccessFromNamespaceSelectors
 */
export interface HelmRepositorySpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmRepositorySpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmRepositorySpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositorySpecAccessFromNamespaceSelectors(obj: HelmRepositorySpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepositoryV1Beta2
 */
export class HelmRepositoryV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HelmRepositoryV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'HelmRepository',
  }

  /**
   * Renders a Kubernetes manifest for "HelmRepositoryV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: HelmRepositoryV1Beta2Props = {}): any {
    return {
      ...HelmRepositoryV1Beta2.GVK,
      ...toJson_HelmRepositoryV1Beta2Props(props),
    };
  }

  /**
   * Defines a "HelmRepositoryV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: HelmRepositoryV1Beta2Props = {}) {
    super(scope, id, {
      ...HelmRepositoryV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...HelmRepositoryV1Beta2.GVK,
      ...toJson_HelmRepositoryV1Beta2Props(resolved),
    };
  }
}

/**
 * HelmRepository is the Schema for the helmrepositories API.
 *
 * @schema HelmRepositoryV1Beta2
 */
export interface HelmRepositoryV1Beta2Props {
  /**
   * @schema HelmRepositoryV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HelmRepositorySpec specifies the required configuration to produce an Artifact for a Helm repository index YAML.
   *
   * @schema HelmRepositoryV1Beta2#spec
   */
  readonly spec?: HelmRepositoryV1Beta2Spec;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryV1Beta2Props(obj: HelmRepositoryV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HelmRepositoryV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HelmRepositorySpec specifies the required configuration to produce an Artifact for a Helm repository index YAML.
 *
 * @schema HelmRepositoryV1Beta2Spec
 */
export interface HelmRepositoryV1Beta2Spec {
  /**
   * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
   *
   * @schema HelmRepositoryV1Beta2Spec#accessFrom
   */
  readonly accessFrom?: HelmRepositoryV1Beta2SpecAccessFrom;

  /**
   * Interval at which to check the URL for updates.
   *
   * @schema HelmRepositoryV1Beta2Spec#interval
   */
  readonly interval: string;

  /**
   * PassCredentials allows the credentials from the SecretRef to be passed on to a host that does not match the host as defined in URL. This may be required if the host of the advertised chart URLs in the index differ from the defined URL. Enabling this should be done with caution, as it can potentially result in credentials getting stolen in a MITM-attack.
   *
   * @schema HelmRepositoryV1Beta2Spec#passCredentials
   */
  readonly passCredentials?: boolean;

  /**
   * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. This field is optional, and only taken into account if the .spec.type field is set to 'oci'. When not specified, defaults to 'generic'.
   *
   * @schema HelmRepositoryV1Beta2Spec#provider
   */
  readonly provider?: HelmRepositoryV1Beta2SpecProvider;

  /**
   * SecretRef specifies the Secret containing authentication credentials for the HelmRepository. For HTTP/S basic auth the secret must contain 'username' and 'password' fields. For TLS the secret must contain a 'certFile' and 'keyFile', and/or 'caFile' fields.
   *
   * @schema HelmRepositoryV1Beta2Spec#secretRef
   */
  readonly secretRef?: HelmRepositoryV1Beta2SpecSecretRef;

  /**
   * Suspend tells the controller to suspend the reconciliation of this HelmRepository.
   *
   * @schema HelmRepositoryV1Beta2Spec#suspend
   */
  readonly suspend?: boolean;

  /**
   * Timeout is used for the index fetch operation for an HTTPS helm repository, and for remote OCI Repository operations like pulling for an OCI helm repository. Its default value is 60s.
   *
   * @schema HelmRepositoryV1Beta2Spec#timeout
   */
  readonly timeout?: string;

  /**
   * Type of the HelmRepository. When this field is set to  "oci", the URL field value must be prefixed with "oci://".
   *
   * @schema HelmRepositoryV1Beta2Spec#type
   */
  readonly type?: HelmRepositoryV1Beta2SpecType;

  /**
   * URL of the Helm repository, a valid URL contains at least a protocol and host.
   *
   * @schema HelmRepositoryV1Beta2Spec#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryV1Beta2Spec(obj: HelmRepositoryV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessFrom': toJson_HelmRepositoryV1Beta2SpecAccessFrom(obj.accessFrom),
    'interval': obj.interval,
    'passCredentials': obj.passCredentials,
    'provider': obj.provider,
    'secretRef': toJson_HelmRepositoryV1Beta2SpecSecretRef(obj.secretRef),
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'type': obj.type,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
 *
 * @schema HelmRepositoryV1Beta2SpecAccessFrom
 */
export interface HelmRepositoryV1Beta2SpecAccessFrom {
  /**
   * NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
   *
   * @schema HelmRepositoryV1Beta2SpecAccessFrom#namespaceSelectors
   */
  readonly namespaceSelectors: HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors[];

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecAccessFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryV1Beta2SpecAccessFrom(obj: HelmRepositoryV1Beta2SpecAccessFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelectors': obj.namespaceSelectors?.map(y => toJson_HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. This field is optional, and only taken into account if the .spec.type field is set to 'oci'. When not specified, defaults to 'generic'.
 *
 * @schema HelmRepositoryV1Beta2SpecProvider
 */
export enum HelmRepositoryV1Beta2SpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * SecretRef specifies the Secret containing authentication credentials for the HelmRepository. For HTTP/S basic auth the secret must contain 'username' and 'password' fields. For TLS the secret must contain a 'certFile' and 'keyFile', and/or 'caFile' fields.
 *
 * @schema HelmRepositoryV1Beta2SpecSecretRef
 */
export interface HelmRepositoryV1Beta2SpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema HelmRepositoryV1Beta2SpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryV1Beta2SpecSecretRef(obj: HelmRepositoryV1Beta2SpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the HelmRepository. When this field is set to  "oci", the URL field value must be prefixed with "oci://".
 *
 * @schema HelmRepositoryV1Beta2SpecType
 */
export enum HelmRepositoryV1Beta2SpecType {
  /** default */
  DEFAULT = "default",
  /** oci */
  OCI = "oci",
}

/**
 * NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
 *
 * @schema HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors
 */
export interface HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors {
  /**
   * MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors(obj: HelmRepositoryV1Beta2SpecAccessFromNamespaceSelectors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepository
 */
export class OciRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OCIRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'source.toolkit.fluxcd.io/v1beta2',
    kind: 'OCIRepository',
  }

  /**
   * Renders a Kubernetes manifest for "OCIRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OciRepositoryProps = {}): any {
    return {
      ...OciRepository.GVK,
      ...toJson_OciRepositoryProps(props),
    };
  }

  /**
   * Defines a "OCIRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OciRepositoryProps = {}) {
    super(scope, id, {
      ...OciRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OciRepository.GVK,
      ...toJson_OciRepositoryProps(resolved),
    };
  }
}

/**
 * OCIRepository is the Schema for the ocirepositories API
 *
 * @schema OCIRepository
 */
export interface OciRepositoryProps {
  /**
   * @schema OCIRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OCIRepositorySpec defines the desired state of OCIRepository
   *
   * @schema OCIRepository#spec
   */
  readonly spec?: OciRepositorySpec;

}

/**
 * Converts an object of type 'OciRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositoryProps(obj: OciRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OciRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OCIRepositorySpec defines the desired state of OCIRepository
 *
 * @schema OciRepositorySpec
 */
export interface OciRepositorySpec {
  /**
   * CertSecretRef can be given the name of a secret containing either or both of
   * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
   * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
   *
   * @schema OciRepositorySpec#certSecretRef
   */
  readonly certSecretRef?: OciRepositorySpecCertSecretRef;

  /**
   * Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
   *
   * @schema OciRepositorySpec#ignore
   */
  readonly ignore?: string;

  /**
   * Insecure allows connecting to a non-TLS HTTP container registry.
   *
   * @schema OciRepositorySpec#insecure
   */
  readonly insecure?: boolean;

  /**
   * The interval at which to check for image updates.
   *
   * @schema OciRepositorySpec#interval
   */
  readonly interval: string;

  /**
   * LayerSelector specifies which layer should be extracted from the OCI artifact. When not specified, the first layer found in the artifact is selected.
   *
   * @schema OciRepositorySpec#layerSelector
   */
  readonly layerSelector?: OciRepositorySpecLayerSelector;

  /**
   * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. When not specified, defaults to 'generic'.
   *
   * @schema OciRepositorySpec#provider
   */
  readonly provider?: OciRepositorySpecProvider;

  /**
   * The OCI reference to pull and monitor for changes, defaults to the latest tag.
   *
   * @schema OciRepositorySpec#ref
   */
  readonly ref?: OciRepositorySpecRef;

  /**
   * SecretRef contains the secret name containing the registry login credentials to resolve image metadata. The secret must be of type kubernetes.io/dockerconfigjson.
   *
   * @schema OciRepositorySpec#secretRef
   */
  readonly secretRef?: OciRepositorySpecSecretRef;

  /**
   * ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate the image pull if the service account has attached pull secrets. For more information: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account
   *
   * @schema OciRepositorySpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * This flag tells the controller to suspend the reconciliation of this source.
   *
   * @schema OciRepositorySpec#suspend
   */
  readonly suspend?: boolean;

  /**
   * The timeout for remote OCI Repository operations like pulling, defaults to 60s.
   *
   * @schema OciRepositorySpec#timeout
   */
  readonly timeout?: string;

  /**
   * URL is a reference to an OCI artifact repository hosted on a remote container registry.
   *
   * @schema OciRepositorySpec#url
   */
  readonly url: string;

  /**
   * Verify contains the secret name containing the trusted public keys used to verify the signature and specifies which provider to use to check whether OCI image is authentic.
   *
   * @schema OciRepositorySpec#verify
   */
  readonly verify?: OciRepositorySpecVerify;

}

/**
 * Converts an object of type 'OciRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpec(obj: OciRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_OciRepositorySpecCertSecretRef(obj.certSecretRef),
    'ignore': obj.ignore,
    'insecure': obj.insecure,
    'interval': obj.interval,
    'layerSelector': toJson_OciRepositorySpecLayerSelector(obj.layerSelector),
    'provider': obj.provider,
    'ref': toJson_OciRepositorySpecRef(obj.ref),
    'secretRef': toJson_OciRepositorySpecSecretRef(obj.secretRef),
    'serviceAccountName': obj.serviceAccountName,
    'suspend': obj.suspend,
    'timeout': obj.timeout,
    'url': obj.url,
    'verify': toJson_OciRepositorySpecVerify(obj.verify),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertSecretRef can be given the name of a secret containing either or both of
 * - a PEM-encoded client certificate (`certFile`) and private key (`keyFile`); - a PEM-encoded CA certificate (`caFile`)
 * and whichever are supplied, will be used for connecting to the registry. The client cert and key are useful if you are authenticating with a certificate; the CA cert is useful if you are using a self-signed server certificate.
 *
 * @schema OciRepositorySpecCertSecretRef
 */
export interface OciRepositorySpecCertSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecCertSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecCertSecretRef(obj: OciRepositorySpecCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LayerSelector specifies which layer should be extracted from the OCI artifact. When not specified, the first layer found in the artifact is selected.
 *
 * @schema OciRepositorySpecLayerSelector
 */
export interface OciRepositorySpecLayerSelector {
  /**
   * MediaType specifies the OCI media type of the layer which should be extracted from the OCI Artifact. The first layer matching this type is selected.
   *
   * @schema OciRepositorySpecLayerSelector#mediaType
   */
  readonly mediaType?: string;

  /**
   * Operation specifies how the selected layer should be processed. By default, the layer compressed content is extracted to storage. When the operation is set to 'copy', the layer compressed content is persisted to storage as it is.
   *
   * @schema OciRepositorySpecLayerSelector#operation
   */
  readonly operation?: OciRepositorySpecLayerSelectorOperation;

}

/**
 * Converts an object of type 'OciRepositorySpecLayerSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecLayerSelector(obj: OciRepositorySpecLayerSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mediaType': obj.mediaType,
    'operation': obj.operation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'. When not specified, defaults to 'generic'.
 *
 * @schema OciRepositorySpecProvider
 */
export enum OciRepositorySpecProvider {
  /** generic */
  GENERIC = "generic",
  /** aws */
  AWS = "aws",
  /** azure */
  AZURE = "azure",
  /** gcp */
  GCP = "gcp",
}

/**
 * The OCI reference to pull and monitor for changes, defaults to the latest tag.
 *
 * @schema OciRepositorySpecRef
 */
export interface OciRepositorySpecRef {
  /**
   * Digest is the image digest to pull, takes precedence over SemVer. The value should be in the format 'sha256:<HASH>'.
   *
   * @schema OciRepositorySpecRef#digest
   */
  readonly digest?: string;

  /**
   * SemVer is the range of tags to pull selecting the latest within the range, takes precedence over Tag.
   *
   * @schema OciRepositorySpecRef#semver
   */
  readonly semver?: string;

  /**
   * Tag is the image tag to pull, defaults to latest.
   *
   * @schema OciRepositorySpecRef#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'OciRepositorySpecRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecRef(obj: OciRepositorySpecRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'digest': obj.digest,
    'semver': obj.semver,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef contains the secret name containing the registry login credentials to resolve image metadata. The secret must be of type kubernetes.io/dockerconfigjson.
 *
 * @schema OciRepositorySpecSecretRef
 */
export interface OciRepositorySpecSecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecSecretRef(obj: OciRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Verify contains the secret name containing the trusted public keys used to verify the signature and specifies which provider to use to check whether OCI image is authentic.
 *
 * @schema OciRepositorySpecVerify
 */
export interface OciRepositorySpecVerify {
  /**
   * Provider specifies the technology used to sign the OCI Artifact.
   *
   * @schema OciRepositorySpecVerify#provider
   */
  readonly provider: OciRepositorySpecVerifyProvider;

  /**
   * SecretRef specifies the Kubernetes Secret containing the trusted public keys.
   *
   * @schema OciRepositorySpecVerify#secretRef
   */
  readonly secretRef?: OciRepositorySpecVerifySecretRef;

}

/**
 * Converts an object of type 'OciRepositorySpecVerify' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecVerify(obj: OciRepositorySpecVerify | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'provider': obj.provider,
    'secretRef': toJson_OciRepositorySpecVerifySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operation specifies how the selected layer should be processed. By default, the layer compressed content is extracted to storage. When the operation is set to 'copy', the layer compressed content is persisted to storage as it is.
 *
 * @schema OciRepositorySpecLayerSelectorOperation
 */
export enum OciRepositorySpecLayerSelectorOperation {
  /** extract */
  EXTRACT = "extract",
  /** copy */
  COPY = "copy",
}

/**
 * Provider specifies the technology used to sign the OCI Artifact.
 *
 * @schema OciRepositorySpecVerifyProvider
 */
export enum OciRepositorySpecVerifyProvider {
  /** cosign */
  COSIGN = "cosign",
}

/**
 * SecretRef specifies the Kubernetes Secret containing the trusted public keys.
 *
 * @schema OciRepositorySpecVerifySecretRef
 */
export interface OciRepositorySpecVerifySecretRef {
  /**
   * Name of the referent.
   *
   * @schema OciRepositorySpecVerifySecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OciRepositorySpecVerifySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OciRepositorySpecVerifySecretRef(obj: OciRepositorySpecVerifySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

