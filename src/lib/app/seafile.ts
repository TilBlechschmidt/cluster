import * as kplus from 'cdk8s-plus-26';
import { Construct } from "constructs";
import { Domain } from "../infra/certManager";
import { createHostPathVolume, generateSecret, obj2env } from "../../helpers";
import { MariaDb } from "../helpers/db/mariadb";
import { Ingress, IngressBackend, Volume } from 'cdk8s-plus-26';
import { Authelia } from '../infra/authelia';

const CONFIG_SEPARATOR = `#AUTOGENERATED_CONFIG_BELOW_DO_NOT_TOUCH`;

export interface SeaFileProps {
    domain: Domain;
    oidc: Authelia;
}

/// Private cloud file storage server
///
/// NOTE: It might be necessary to restart the container once after initial boot to apply all configs
export class SeaFile extends Construct {
    constructor(scope: Construct, id: string, props: SeaFileProps) {
        super(scope, id);

        const dbPassword = generateSecret(`${id}-seafile-mariadb`, 32);
        const db = new MariaDb(this, 'sql', { password: dbPassword });

        const secret = new kplus.Secret(this, 'user', {
            stringData: {
                DB_ROOT_PASSWD: dbPassword,
                SEAFILE_ADMIN_PASSWORD: generateSecret(`${id}-seafile-admin-pwd`, 32),
            }
        });

        const service = new kplus.Service(this, id, {
            type: kplus.ServiceType.CLUSTER_IP,
            ports: [{ port: 80, targetPort: 80 }],
        });

        const statefulSet = new kplus.StatefulSet(this, 'app', {
            service,
            // Since `memcached` is hardcoded in the image we have to add it here
            hostAliases: [{
                hostnames: ['memcached'],
                ip: '127.0.0.1'
            }]
        });

        const initContainer = statefulSet.addInitContainer({
            image: 'alpine:latest',
            command: ['/bin/sh'],
            // 1. Check if initialization has been performed, else exit with code 0
            // 2. Copy & overwrite the `seafdav.conf` file
            // 3. Strip potentially previously injected lines from `seahub_settings.py`
            // 4. Append settings to `seahub_settings.py`
            args: ['-c', `[[ -f /shared/seafile/conf/seahub_settings.py ]] || exit 0; cp -f /config/seafdav.conf /shared/seafile/conf/seafdav.conf; sed -i -n '/${CONFIG_SEPARATOR}/q;p' /shared/seafile/conf/seahub_settings.py; cat /config/seahub_settings.py | tee -a /shared/seafile/conf/seahub_settings.py`],
            securityContext: {
                ensureNonRoot: false
            },
            resources: {}
        });

        statefulSet.addContainer({
            image: 'memcached:1.6.18',
            command: ['memcached'],
            args: ['-m', '256'],
            name: 'memcached',
            portNumber: 11211,
            securityContext: {
                ensureNonRoot: false,
                readOnlyRootFilesystem: false
            },
            resources: {},
        });

        const container = statefulSet.addContainer({
            image: 'seafileltd/seafile-mc:11.0.3',
            portNumber: 80,
            envFrom: [kplus.Env.fromSecret(secret)],
            envVariables: obj2env({
                DB_HOST: db.serviceName,
                TIME_ZONE: 'Europe/Berlin',
                SEAFILE_ADMIN_EMAIL: `admin@${props.domain.fqdn}`,
                SEAFILE_SERVER_LETSENCRYPT: 'false',
                SEAFILE_SERVER_HOSTNAME: props.domain.fqdn
            }),
            securityContext: {
                ensureNonRoot: false,
                readOnlyRootFilesystem: false
            },
            resources: {}
        });

        const configSecret = this.generateConfigSecret(props);
        const volume = createHostPathVolume(this, `data`);

        container.mount('/shared', volume);
        initContainer.mount('/shared', volume);
        initContainer.mount('/config', Volume.fromSecret(this, 'config', configSecret));

        new Ingress(this, props.domain.fqdn, {
            rules: [{
                host: props.domain.fqdn,
                backend: IngressBackend.fromService(service, { port: 80 })
            }]
        });
    }

    generateConfigSecret(props: SeaFileProps) {
        const redirectURI = `https://${props.domain.fqdn}/oauth/callback/`;
        const clientSecret = props.oidc.registerClient(this.node.id, {
            description: 'SeaFile cloud storage',
            redirect_uris: [redirectURI],
            userinfo_signing_algorithm: 'none'
        }, true);

        // Some properties already exist in the config but we overwrite them
        // by simply appending them to the file again
        const seahubConfig = `
${CONFIG_SEPARATOR}
SERVICE_URL = "https://${props.domain.fqdn}/"
CSRF_TRUSTED_ORIGINS=["https://${props.domain.fqdn}"]
FILE_SERVER_ROOT = "https://${props.domain.fqdn}/seafhttp"

ENABLE_OAUTH = True
OAUTH_ENABLE_INSECURE_TRANSPORT = False

OAUTH_CLIENT_ID = "${this.node.id}"
OAUTH_CLIENT_SECRET = "${clientSecret}"

OAUTH_REDIRECT_URL = '${redirectURI}'

OAUTH_PROVIDER_DOMAIN = '${props.oidc.domain.fqdn}'
OAUTH_AUTHORIZATION_URL = 'https://${props.oidc.domain.fqdn}/api/oidc/authorization'
OAUTH_TOKEN_URL = 'https://${props.oidc.domain.fqdn}/api/oidc/token'
OAUTH_USER_INFO_URL = 'https://${props.oidc.domain.fqdn}/api/oidc/userinfo'

OAUTH_SCOPE = [
    "openid",
    "profile",
    "email",
]

OAUTH_ATTRIBUTE_MAP = {
    # Seafile will create a unique identifier of your <LDAP User ID>@<OAUTH_PROVIDER_DOMAIN>. 
    # The identifier is not visible to the user and not actually used as the email address unlike the value suggests.
    "preferred_username": (True, "email"),
    "name": (False, "name"),
    "id": (False, "not used"),
    "email": (False, "contact_email")
}

ENABLE_WEBDAV_SECRET = True
WEBDAV_SECRET_MIN_LENGTH = 16
`;

        const seafdavConfig = `
[WEBDAV]
enabled = true
port = 8080
share_name = /seafdav
        `;

        return new kplus.Secret(this, 'settings', {
            stringData: {
                'seahub_settings.py': seahubConfig,
                'seafdav.conf': seafdavConfig
            }
        });
    }
}
